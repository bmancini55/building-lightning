<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building on Lightning</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Building on Lightning</a></li><li class="chapter-item expanded "><a href="app1/intro.html"><strong aria-hidden="true">1.</strong> Lightning Graph Visualizer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app1/part1.html"><strong aria-hidden="true">1.1.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="app1/part2.html"><strong aria-hidden="true">1.2.</strong> Code Setup</a></li><li class="chapter-item expanded "><a href="app1/part3.html"><strong aria-hidden="true">1.3.</strong> Building the Server</a></li><li class="chapter-item expanded "><a href="app1/part4.html"><strong aria-hidden="true">1.4.</strong> Building the UI</a></li><li class="chapter-item expanded "><a href="app1/part5.html"><strong aria-hidden="true">1.5.</strong> Real-Time Updates</a></li><li class="chapter-item expanded "><a href="app1/part6.html"><strong aria-hidden="true">1.6.</strong> Exploration</a></li></ol></li><li class="chapter-item expanded "><a href="app2/intro.html"><strong aria-hidden="true">2.</strong> Lightning Network Invoices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app2/part0-1.html"><strong aria-hidden="true">2.1.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="app2/part0-2.html"><strong aria-hidden="true">2.2.</strong> Creating an Invoice in Code</a></li><li class="chapter-item expanded "><a href="app2/part1-1.html"><strong aria-hidden="true">2.3.</strong> Application Walk-Through</a></li><li class="chapter-item expanded "><a href="app2/part1-2.html"><strong aria-hidden="true">2.4.</strong> Application Algorithm</a></li><li class="chapter-item expanded "><a href="app2/part3.html"><strong aria-hidden="true">2.5.</strong> Creating the Invoice Class</a></li><li class="chapter-item expanded "><a href="app2/part4.html"><strong aria-hidden="true">2.6.</strong> Loading Invoices</a></li><li class="chapter-item expanded "><a href="app2/part5.html"><strong aria-hidden="true">2.7.</strong> Creating the Link Class</a></li><li class="chapter-item expanded "><a href="app2/part6.html"><strong aria-hidden="true">2.8.</strong> Creating the LinkFactory Class</a></li><li class="chapter-item expanded "><a href="app2/part7.html"><strong aria-hidden="true">2.9.</strong> Creating the AppController Class</a></li><li class="chapter-item expanded "><a href="app2/part8.html"><strong aria-hidden="true">2.10.</strong> Putting It All Together</a></li><li class="chapter-item expanded "><a href="app2/part9.html"><strong aria-hidden="true">2.11.</strong> Exploration</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/intro.html"><strong aria-hidden="true">3.</strong> Advanced Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/env_setup.html"><strong aria-hidden="true">3.1.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="advanced/hold_invoices.html"><strong aria-hidden="true">3.2.</strong> Hold Invoices</a></li><li class="chapter-item expanded "><a href="advanced/spontanenous_keysend.html"><strong aria-hidden="true">3.3.</strong> Spontaneous Payments with Keysend</a></li><li class="chapter-item expanded "><a href="advanced/circular_rebalance.html"><strong aria-hidden="true">3.4.</strong> Circular Rebalancing</a></li><li class="chapter-item expanded "><a href="advanced/loop_out.html"><strong aria-hidden="true">3.5.</strong> Loop-Out Service</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building on Lightning</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="building-on-lightning"><a class="header" href="#building-on-lightning">Building on Lightning</a></h1>
<p>Welcome to the Building on Lightning tutorial!</p>
<p>This tutorial will help you become familiar with creating applications that interact with the Lightning Network.</p>
<p>This tutorial is for individuals with some familiarity of the Lightning Network and that have moderate software development experience. The applications are written with TypeScript and Node.js. These tools were used because API and backend systems for websites and mobile applications frequently use Node.js. The static typing of TypeScript help with code clarity and provide real time feedback while coding.</p>
<p>This tutorial will walk you through two applications.</p>
<p>The first application will get you comfortable building an application that connects to a Lightning Network node. It will render a visualization of the node's network graph. While the focus of these tutorials isn't UI development, this application will have some UI components to show you how information can be threaded through an application.</p>
<p>The second application will focus on invoices. It will construct a simple game of ownership using paid invoices. With this application you will become familiar with code to create, retrieve, and monitor invoices.</p>
<p>The last section of this tutorial will cover advanced Lightning Network topics. These scripts will highlight some of the experimental and lower level tooling you may need when building more complicated Lightning Network applications.</p>
<p>Happy Coding!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visualizing-the-lightning-network"><a class="header" href="#visualizing-the-lightning-network">Visualizing the Lightning Network</a></h1>
<p>Welcome to Building on Lightning! This series will acquaint you with tools and techniques you will need to build Lightning Network applications. The first application we will build is a visualizer of the nodes and channels from the perspective of one node in Lightning Network. You will learn how to connect a web application to a Lightning Network node and receive real-time updates from that node.</p>
<p>This project uses <a href="https://www.typescriptlang.org/">TypeScript</a> in the <a href="https://nodejs.org/en/">Node.js</a> runtime. If you're not familiar with TypeScript, you may want to do a tutorial to help you understand the code. Node.js is a popular runtime for web development. When combined with TypeScript it allows us to build large applications with compile-time type checking. This helps us reduce mistakes and properly structure our applications for future changes. This project also uses <a href="https://expressjs.com">Express</a> as the web framework. It is a fast, easy to use, and popular web framework. Lastly this project uses <a href="https://reactjs.org/">React</a> and <a href="https://d3js.org/">D3</a> for creating the visualization of the Lightning Network graph.</p>
<h2 id="the-lightning-network-as-a-graph"><a class="header" href="#the-lightning-network-as-a-graph">The Lightning Network as a Graph</a></h2>
<p>We'll start with a brief discussion of why we can conceptualize the Lightning Network as a graph. The Lightning Network consists of many computers running software that understands the Lightning Network protocols as defined in the <a href="https://github.com/lightning/bolts/blob/master/00-introduction.md">BOLT specifications</a>. The goal is to allow trustless, bidirectional, off-chain payments between nodes. So why is a picture of the network important?</p>
<p>Let's first consider payments between just two nodes: Alice and Carol. If Alice wants to pay Carol, she needs to know how to connect to Carol (the IP and port on which Carol's Lightning Network software is accessible). We refer to directly establishing a communication channel as becoming a peer. Once Alice and Carol are peers, Alice can establish a payment channel with Carol and finally pay her.</p>
<p>This sounds good, but if this was all the Lightning Network was, it has a major shortcoming. Every payment requires two nodes to become peers and establish channels. This means there are delays in sending a first payment, on-chain cost to establish channels, and ongoing burden to manage the growing set of channels.</p>
<p>Instead, the Lightning Network allows us to trustlessly route payments through other nodes in the network. If Alice wants to pay Carol, Alice doesn't need to be directly connected to Carol. Alice can pay Bob and Bob can pay Carol. However, Alice must <em>know</em> that she can pay through Bob.</p>
<blockquote>
<p>The prerequisite for routed payments is that you need an understanding of the paths that a payment can take.</p>
</blockquote>
<p>Without this understanding we cannot construct a route to make our payment.</p>
<p>Conceptually we can think of the nodes and channels topology as a graph data structure. Each computer running Lightning Network software is a node in the graph. Each node is uniquely identified by a public key. The edges of the graph are the <em>public</em> channels that exist between nodes. The channels are uniquely identified by the UTXO of the channel's funding transaction.</p>
<p>One consideration is that there is no such thing as a complete picture of the Lightning Network. The Lightning Network allows for private channels between nodes. Only nodes participating in a private channel will see these edges in their view of the network. As a result, the Lightning Network is much larger than the topology created by public channels alone.</p>
<p>Another observation is that we often see visuals of the Lightning Network as an undirected graph. This makes sense when we are trying to get a picture of what channels exist. However there are complications when routing payments. Some balance of funds can exist on either side of the channel. This means that our ability to route through a channel is actually directional. For practical and privacy purposes, the balance on each side of the channel is opaque.</p>
<p>This is a lot to unpack, but if you're curious and want to dig deeper into how node's gossip about the topology and how they perform route path finding, refer to Chapters 11 and 12 in <em>Mastering the Lightning Network</em> by Antonopoulos et al.</p>
<p>For this visualization we'll be treating the graph as undirected. So without further ado, let's get started building!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-setup"><a class="header" href="#environment-setup">Environment Setup</a></h1>
<p>We'll start by setting up your environment. Since we're going to build a Lightning Network application it should not be surprising that our infrastructure consists of a Bitcoin node and one or more Lightning Network nodes that we can control.</p>
<p>As a user of Bitcoin and the Lightning Network you are most likely familiar with the main Bitcoin network. Bitcoin software actually has multiple networks that it can run on:</p>
<ul>
<li>mainnet - primary public network; the network a user interacts with.</li>
<li>testnet - alternate network used for testing. It is typically smaller in size and has some other properties that make it useful for testing software built on top of Bitcoin. <a href="https://en.bitcoin.it/wiki/Testnet">More info</a>.</li>
<li>regtest - regression testing network that gives us full control of block creation.</li>
</ul>
<p>For creating and testing our Lightning Network applications we'll want our infrastructure to start with the regtest network to give us control and speed up our development process. At a future time we can transition to running in testnet or mainnet.</p>
<p>As you can imagine, getting all this running can be a chore. Fortunately, there is the tool <a href="https://lightningpolar.com">Polar</a> that allows us to spin up Lightning network testing environments easily!</p>
<p>Our first step is to download and install Polar for your operating system from the <a href="https://lightningpolar.com">website</a>.</p>
<p>For a Linux system, it will be as an AppImage. You will need to grant executable rights to the file, then you can run the application.</p>
<p>For Mac it will be a .dmg file that you will need to install.</p>
<p>For Windows, it will be an .exe file that you can run.</p>
<p>Once Polar is running, you can create a new network. Polar allows us to run many different networks with varying configurations. For this application we will start the network with 1 LND node, 1 c-lightning node, 1 Eclair, and 1 Bitcoin Core node. Provide a name for this network and create it!</p>
<p><img src="app1/../images/ch1_polar_create.png" alt="Polar Network" /></p>
<p>Next, start the network. Polar will launch Docker containers for each of the nodes in your network. This may take a few minutes for the nodes to come online.</p>
<p>Polar also provides a few tools to allow us to easily perform common tasks.</p>
<p>We will start by depositing some funds into Alice's node. To do this, click on Alice's node, then click on the <code>Actions</code> tab.</p>
<p>We will then deposit 1,000,000 satoshis into Alice's node. When you click the <code>Deposit</code> button, the Bitcoin Core node running in regtest will create new blocks to an address and 0.01000000 bitcoin (1,000,000 satoshis) will deposited into an address controlled by Alice's Lightning Network node.</p>
<p><img src="app1/../images/ch1_polar_deposit.png" alt="Alice with 1mil Sats" /></p>
<p>Now that Alice has some funds, she can create a channel with another node on the network. We can do this by opening an outgoing channel by clicking the <code>Outgoing</code> button in the <code>Open Channel</code> section of Alice's Actions tab.</p>
<p>Let's choose Bob as the channel counterparty and fund the channel with 250,000 satoshis.</p>
<p><img src="app1/../images/ch1_polar_open_channel.png" alt="Alice to Bob Create Channel" /></p>
<p>We should now see a channel link between Alice and Bob in our channel graph.</p>
<p><img src="app1/../images/ch1_polar_alice_bob.png" alt="Alice to Bob Channel" /></p>
<p>At this point, we are ready to write some code!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-setup"><a class="header" href="#code-setup">Code Setup</a></h1>
<p>Before we get started writing code, we have a few small things we need to take care of.</p>
<h2 id="ide-setup"><a class="header" href="#ide-setup">IDE Setup</a></h2>
<p>For web applications, I like to use <a href="https://code.visualstudio.com/">Visual Studio Code</a> as my IDE. It has excellent tooling for TypeScript and web development. I install the ESLint and Prettier plugins to give me real time feedback of any problems that my application may have.</p>
<h2 id="runtime-setup"><a class="header" href="#runtime-setup">Runtime Setup</a></h2>
<p>You will need to install <a href="https://nodejs.org/en/">Node.js 16</a> by following the instructions for your operating system.</p>
<h2 id="repository-setup"><a class="header" href="#repository-setup">Repository Setup</a></h2>
<p>With general prerequisites setup, we can now clone the repository:</p>
<p>Clone the repository:</p>
<pre><code>git clone https://github.com/bmancini55/building-lightning-graph.git
</code></pre>
<p>Navigate to the repository:</p>
<pre><code>cd building-lightning-graph
</code></pre>
<p>The repository uses <code>npm</code> scripts to perform common tasks. To install the dependencies, run:</p>
<pre><code>npm install
</code></pre>
<p>This will install all of the dependencies for the three sub-modules in the project: <code>client</code>, <code>server</code>, and <code>style</code>. You may get some warnings, but as long as the install command has exit code 0 for all three sub-projects you should be good. If you do encounter any errors, you can try browsing to the individual sub-project and running the <code>npm install</code> command inside each directory.</p>
<h2 id="repository-walk-through"><a class="header" href="#repository-walk-through">Repository Walk-Through</a></h2>
<p>The repository is split into three parts, each of which has a <code>package.json</code> to install Node.js dependencies for that sub-application. Each also has unique set of <code>npm</code> scripts that can be run. The three parts are:</p>
<ol>
<li><code>client</code> - Our React application lives in this directory.</li>
<li><code>server</code> - Our Express server code lives in this directory.</li>
<li><code>style</code> - Our code to create CSS lives here.</li>
</ol>
<p>We will discuss the <code>client</code> and <code>server</code> sections in more detail as we go through the various parts of the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-an-api"><a class="header" href="#creating-an-api">Creating an API</a></h1>
<p>Our first coding task is going to be creating a REST API of our own to provide graph information to our application. We'll start by getting our server connected to Alice's LND node.</p>
<h2 id="connecting-to-alices-node"><a class="header" href="#connecting-to-alices-node">Connecting to Alice's node</a></h2>
<p>We've chosen to connect to LND for this application but we could just as easily use c-lightning or Eclair.</p>
<p>LND also a <a href="https://docs.lightning.engineering/">Builder's Guide</a> that you may want to explore to learn more about commonly performed tasks.</p>
<p>LND has two ways we can interact with it from code: a <a href="https://api.lightning.community/#lnd-rest-api-reference">REST API</a> and a <a href="https://api.lightning.community/#lnd-grpc-api-reference">gRPC API</a>. gRPC is a high performance RPC framework. With gRPC, the wire protocol is defined in a protocol definition file. This file is used by a code generators to construct a client in the programming language of your choice. gRPC is a fantastic mechanism for efficient network communication, but it comes with a bit of setup cost. The REST API requires less effort to get started but is less efficient over the wire. For applications with a large amount of interactivity, you would want to use gRPC connectivity. For this application we'll be using the REST API because it is highly relatable for web developers.</p>
<h2 id="lnd-api-client"><a class="header" href="#lnd-api-client">LND API Client</a></h2>
<p>Inside our <code>server</code> sub-project is the start of code to connect to LND's REST API. We'll add to this for our application.</p>
<p>Why are we not leveraging an existing library from NPM? The first reason is that it is a nice exercise to help demonstrate how we can build connectivity. Lightning Network is still a nascent technology and developers need to be comfortable building tools to help them interact with Bitcoin and Lightning Network nodes. The second and arguably more important reason is that as developers in the Bitcoin ecosystem, we need to be extremely wary of outside packages that we pull into our projects, especially if they are cryptocurrency related. Outside dependencies pose a security risk that could compromise our application. As such, my general rule is that runtime dependencies should generally be built unless it is burdensome to do so and maintain.</p>
<p>With that said, point your IDE at the <code>server/src/domain/lnd/LndRestTypes.ts</code> file. This file contains a subset of TypeScript type definitions from the <a href="https://api.lightning.community/#lnd-rest-api-reference">REST API</a> documentation. We are only building a subset of the API that we'll need for understanding the graph.</p>
<h2 id="exercise--defining-the-graph-type"><a class="header" href="#exercise--defining-the-graph-type">Exercise : Defining the <code>Graph</code> Type</a></h2>
<p>In <code>LndRestTypes</code> you'll see our first exercise. It requires us to define the resulting object obtained by calling LND's <a href="https://api.lightning.community/#v1-graph"><code>/v1/graph</code></a> API. You will need to add two properties to the <code>Graph</code> interface. To help you, the <code>LightningNode</code> and <code>ChannelEdge</code> types are already defined. In TypeScript, you can define an array as such</p>
<pre><code class="language-typescript">// server/src/domain/lnd/LndRestTypes

export interface Graph {
  // Exercise: define the `nodes` and `edges` properties in this interface.
  // These arrays of LightningNode and ChannelEdge objects.
}
</code></pre>
<h2 id="exercise-making-the-call"><a class="header" href="#exercise-making-the-call">Exercise: Making the Call</a></h2>
<p>Now that we've defined the results from a call to <a href="https://api.lightning.community/#v1-graph"><code>/v1/graph</code></a>, we need to point our IDE at <code>server/src/domain/lnd/LndRestClient.ts</code> so we can write the code that makes this API call.</p>
<p><code>LndRestClient</code> implements a basic LND REST client. We can add methods to it that are needed by our application. It also takes care of the heavy lifting for establishing a connection to LND. You'll notice that the constructor takes three parameters: <code>host</code>, <code>macaroon</code>, and <code>cert</code>. The <code>macaroon</code> is similar to a security token. The macaroon that you provide will dictate the security role you use when calling the API. The <code>cert</code> is a TLS certificate that enables a secure and authenticated connection to LND.</p>
<pre><code class="language-typescript">// server/src/domain/lnd/LndRestClient

export class LndRestClient {
  constructor(
    readonly host: string,
    readonly macaroon: Buffer,
    readonly cert: Buffer
  ) {}
}
</code></pre>
<p>This class also has a <code>get</code> method that is a helper for making HTTP GET requests to LND. This helper method applies the macaroon and ensures the connection is made using the TLS certificate.</p>
<p>Your next exercise is to implement the <code>getGraph</code> method in <code>server/src/domain/lnd/LndRestClient.ts</code>. Use the <code>get</code> helper method to call the <a href="https://api.lightning.community/#v1-graph"><code>/v1/graph</code></a> API and return the results.</p>
<pre><code class="language-typescript">// server/src/domain/lnd/LndRestClient

  public async getGraph(): Promise&lt;Lnd.Graph&gt; {
      // Exercise: use the `get` method below to call `/v1/graph` API
      // and return the results
  }
</code></pre>
<p>After this is complete, we should have a functional API client. In order to test this we will need to provide the macaroon and certificate.</p>
<h2 id="exercise-configuring-env-to-connect-to-lnd"><a class="header" href="#exercise-configuring-env-to-connect-to-lnd">Exercise: Configuring <code>.env</code> to Connect to LND</a></h2>
<p>In this application we use the <code>dotenv</code> package to simplify environment variables. We can populate a <code>.env</code> file with key value pairs and the application will treat these as environment variables.</p>
<p>Remember that environment variables can be read in Node.js from the <code>process.env</code> object. So if we have an environment variable <code>PORT</code>:</p>
<pre><code>$ export PORT=8000
$ node app.js
</code></pre>
<p>This environment variable can be read with:</p>
<pre><code class="language-typescript">const port = process.env.PORT;
</code></pre>
<p>Our next exercise is adding some values to <code>.env</code> inside the <code>server</code> sub-project. We'll add three new environment variables:</p>
<ul>
<li><code>LND_HOST</code> is the host where our LND node resides</li>
<li><code>LND_READONLY_MACAROON_PATH</code> is the file path to the readonly Macaroon</li>
<li><code>LND_CERT_PATH</code> is the certificate we use to securely connect with LND</li>
</ul>
<p>Fortunately, Polar provides us with a nice interface with all of this information. Polar also conveniently puts files in our local file system to make our lives as developers a bit easier.</p>
<p>In Polar, to access Alice's node by click on Alice and then click on the <code>Connect</code> tab. You will be shown the information on how to connect to the GRPC and REST interfaces. Additionally you will be given paths to the network certificates and macaroon files that we will need in <code>.env</code>.</p>
<p><img src="app1/../images/ch1_polar_connect_to_alice.png" alt="Connect to Alice" /></p>
<p>Go ahead and add the three environment variables defined above to <code>.env</code>.</p>
<pre><code># Express configuration
PORT=8001

# LND configuration
# Exercise: Provide values for Alice's node
LND_HOST=
LND_READONLY_MACAROON_PATH=
LND_CERT_PATH=
</code></pre>
<h2 id="exercise-reading-the-options"><a class="header" href="#exercise-reading-the-options">Exercise: Reading the Options</a></h2>
<p>Now that our environment variables are in our configuration file, we need to get them into the application. The server project uses <code>server/src/Options</code> to read and store application options.</p>
<p>The class contains a factory method <code>fromEnv</code> that allows us to construct our options from environment variables. We're going to modify the <code>Options</code> class to read our newly defined environment variables.</p>
<p>This method is partially implemented, but your next exercise is to finish the method by reading the cert file into a Buffer.</p>
<pre><code class="language-typescript">// server/src/Options

  public static async fromEnv(): Promise&lt;Options&gt; {
    const port: number = Number(process.env.PORT),
    const host: string = process.env.LND_HOST,
    const macaroon: Buffer = await fs.readFile(process.env.LND_READONLY_MACAROON_PATH),

    // Exercise: Using fs.readFile read the file in the LND_CERT_PATH
    // environment variable
    const cert: Buffer = undefined;

    return new Options(port, host, macaroon, cert);
  }
</code></pre>
<p>Note: In this example we use TypeScript's <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties">Parameter Properties</a> feature. This feature creates class properties from <code>readonly</code> parameters. I like it because it saves a few keystrokes by removing the boilerplate of defining the property in the class, then assigning its value in the constructor. There are pros and cons to this approach, so feel free to construct your objects how think is best and in a way that is likely to reduce errors.</p>
<h2 id="exercise-create-the-lnd-client"><a class="header" href="#exercise-create-the-lnd-client">Exercise: Create the LND client</a></h2>
<p>The last step before we can see if our application can connect to LND is that we need to create the LND client! We will do this in the entrypoint of our server code <code>server/src/Server</code>.</p>
<p>In this exercise, construct an instance of the <code>LndRestClient</code> type and supply it with the options found in the <code>options</code> variable.</p>
<pre><code class="language-typescript">// server/src/Server

  async function run() {
    // construct the options
    const options = await Options.fromEnv();

    // Exercise: using the Options defined above, construct an instance
    // of the LndRestClient using the options.
    const lnd: LndRestClient = undefined;

    // construct an IGraphService for use by the application
    const graphAdapter: IGraphService = new LndGraphService(lnd);
</code></pre>
<p>At this point, our server code is ready. We'll take a look at a few other things before we give it a test.</p>
<h2 id="looking-at-lndgraphservice"><a class="header" href="#looking-at-lndgraphservice">Looking at LndGraphService</a></h2>
<p>The <code>LndRestClient</code> instance that we just created will be used by <code>LndGraphService</code>. This class follows the adapter design pattern: which is a way to make code that operates in one way, adapt to another use. The <code>LndGraphService</code> is the place where we make the <code>LndRestClient</code> do things that our application needs.</p>
<pre><code class="language-typescript">export class LndGraphService extends EventEmitter implements IGraphService {
    constructor(readonly lnd: LndRestClient) {
        super();
    }

    /**
     * Loads a graph from LND and returns the type. If we were mapping
     * the returned value into a generic Graph type, this would be the
     * place to do it.
     * @returns
     */
    public async getGraph(): Promise&lt;Lnd.Graph&gt; {
        return await this.lnd.getGraph();
    }
</code></pre>
<p>For the purposes of fetching the graph, we simply call <code>getGraph</code> on the <code>LndRestClient</code> and return the results. But if we modified our application to use a generic graph instead of the one returned by LND, we could do that translation between the <code>Lnd.Graph</code> type and our application's graph here.</p>
<p>At this point your server should capable of connecting to LND!</p>
<h2 id="looking-at-the-graph-api"><a class="header" href="#looking-at-the-graph-api">Looking at the Graph API</a></h2>
<p>Since we're building a REST web service to power our front end application, we need to define an endpoint in our Express application.</p>
<p>Take a look at <code>server/src/Server</code>. We're doing a lot of things in this file for simplicity sake. About half-way down you'll see a line:</p>
<pre><code class="language-typescript">// server/src/Server

app.use(graphApi(graphAdapter));
</code></pre>
<p>This code attaches a router to the Express application.</p>
<p>The router is defined in <code>server/src/api/GraphApi</code>. This file returns a function that accepts our <code>IGraphService</code> that we were just taking a look at. You can then see that we use the <code>IGraphService</code> inside an Express request handler and then return the graph as JSON.</p>
<pre><code class="language-typescript">// server/src/api/GraphApi

export function graphApi(graphService: IGraphService): express.Router {
  // Construct a router object
  const router = express();

  // Adds a handler for returning the graph. By default express does not
  // understand async code, but we can easily adapt Express by calling
  // a promise based handler and if it fails catching the error and
  // supplying it with `next` to allow Express to handle the error.
  router.get(&quot;/api/graph&quot;, (req, res, next) =&gt; getGraph(req, res).catch(next));

  /**
   * Handler that obtains the graph and returns it via JSON
   */
  async function getGraph(req: express.Request, res: express.Response) {
    const graph = await graphService.getGraph();
    res.json(graph);
  }

  return router;
}
</code></pre>
<p>Dev Note: Express does not natively understanding <code>async</code> code but we can easily retrofit it. To do this we define the handler with a lambda function that has arguments for the <code>Request</code>, <code>Response</code>, and <code>next</code> arguments (has the type <code>(req, res, next) =&gt; void</code>). Inside that lambda, we then call our async code and attach the <code>catch(next)</code> to that function call. This way if our <code>async</code> function has an error, it will get passed to Express' error handler!</p>
<p>We can now run <code>npm run watch</code> at the root of our application and our server should start up and connect to LND without issue.</p>
<p>If you're getting errors, check your work by making sure Polar is running, the environment variables are correct, and you've correctly wired the code together.</p>
<p>You can now access <a href="http://localhost:8001/api/graph">http://localhost:8001/api/graph</a> in your browser and you'll see information about the network as understood by Alice!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h1>
<p>Now that we have a functioning server, let's jump into the user interface! This application uses the React.js framework and D3.js. If you're not familiar with React, I suggest finding a tutorial to get familiar with the concepts and basic mechanics. We'll again be using TypeScript for our React code to help us add compile-time type-checking.</p>
<h2 id="exploring-the-user-interface"><a class="header" href="#exploring-the-user-interface">Exploring the User Interface</a></h2>
<p>The user interface sub-project lives inside the <code>client</code> folder of our repository. Inside <code>client/src</code> is our application code.</p>
<p>The entry point of the application is <code>App.tsx</code>. This code uses <code>react-router</code> to allow us to link URLs to various scenes of our application. Once we've built-up our entry point we embed the application into the DOM.</p>
<pre><code class="language-typescript">// client/src/App

import React from &quot;react&quot;;
import ReactDom from &quot;react-dom&quot;;
import { BrowserRouter } from &quot;react-router-dom&quot;;
import { LayoutScene } from &quot;./scenes/layout/LayoutScene&quot;;

ReactDom.render(
  &lt;BrowserRouter&gt;
    &lt;LayoutScene /&gt;
  &lt;/BrowserRouter&gt;,
  document.getElementById(&quot;app&quot;)
);
</code></pre>
<p>From this you will see that we render a single component, <code>&lt;LayoutScene&gt;</code>. It lives inside <code>client/src/scenes/layout</code>. Inside this folder is where we define things related to our application layout.</p>
<p>The <code>LayoutScene</code> component is also where we use <code>react-router</code> to define our various scenes based on the URL path.</p>
<pre><code class="language-typescript">// client/src/scenes/layout/LayoutScene

import React from &quot;react&quot;;
import { Route, Routes } from &quot;react-router-dom&quot;;
import { AppNav } from &quot;./components/AppNav&quot;;
import { GraphScene } from &quot;../graph/GraphScene&quot;;

export const LayoutScene = () =&gt; {
  return (
    &lt;div className=&quot;layout&quot;&gt;
      &lt;div className=&quot;container-fluid mb-3&quot;&gt;
        &lt;AppNav /&gt;
      &lt;/div&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;GraphScene /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Here you can see that inside the <code>&lt;Routes&gt;</code> component we define a single <code>&lt;Route&gt;</code> that is bound to the root path <code>/</code>. This route renders the <code>GraphScene</code> component which renders our graph!</p>
<p>So our folder structure looks like this:</p>
<pre><code>client\
  src\
    App.tsx
    scenes\
      layout\
        LayoutScene.tsx
      graph\
        GraphScene.tsx
</code></pre>
<p>And our code component hierarchy looks like this:</p>
<pre><code>App
  LayoutScene
    GraphScene
</code></pre>
<p>Each of the scenes can also have components that are specific to the the scene. These are stored inside the <code>components</code> folder inside each scene.</p>
<pre><code>client\
  src\
    App.tsx
    scenes\
      layout\
        LayoutScene.tsx
        components\
          NavBar.tsx
      graph\
        GraphScene.tsx
        components\
          Graph.tsx
</code></pre>
<p>Because we're already ran <code>npm run watch</code> at the root of the application, our client side code is already being built for us.</p>
<p>This command builds the React application and place it into the <code>dist</code> folder.</p>
<p>You can now use your browser to navigate to <a href="http://localhost:8001">http://localhost:8001</a> and view the application!</p>
<p><img src="app1/../images/ch1_app_01.png" alt="Blank Slate" /></p>
<h2 id="exercise-loading-the-graph"><a class="header" href="#exercise-loading-the-graph">Exercise: Loading the Graph</a></h2>
<p>Our next task is wiring up the graph API we previously created to our user interface. To make our life easier we will use an <code>ApiService</code> to house the calls to our API.</p>
<p>In your IDE, navigate to <code>/client/src/services/ApiService.ts</code> and create a method that uses the get helper <code>get</code> to retrieve the graph.</p>
<pre><code class="language-typescript">// client/src/services/ApiService

import { Lnd } from &quot;./ApiTypes&quot;;

export class ApiService {
  constructor(readonly host: string = &quot;http://127.0.0.1:8001&quot;) {}

  protected async get&lt;T&gt;(path: string): Promise&lt;T&gt; {
    const res = await fetch(path, { credentials: &quot;include&quot; });
    return await res.json();
  }

  // Exercise: Create a public fetchGraph method that returns Promise&lt;Lnd.Graph&gt;.
  // You can use the get helper method above by supplying it with the path /api/graph.
  public async fetchGraph(): Promise&lt;Lnd.Graph&gt; {
    return undefined;
  }
}
</code></pre>
<p>This class is conveniently accessible by using the <code>useApi</code> hook located in the <code>hooks</code> folder. By adding our <code>fetchGraph</code> method to the <code>ApiService</code>, we can gain access to it with the <code>useApi</code> hook inside any component! Feel free to take a look at the <code>useApi</code> hook code and if you're confused read up on React hooks.</p>
<h2 id="exercise-wire-up-the-api-call"><a class="header" href="#exercise-wire-up-the-api-call">Exercise: Wire up the API Call</a></h2>
<p>Next let's point our IDE at the <code>GraphScene</code> component in <code>client/src/scenes/graph</code> and see if we can wire up the API to a component.</p>
<p>For this exercise, inside the <code>useEffect</code> hook, call the api's <code>fetchGraph</code> method. Be mindful that this method returns a promise, which you will need to retrieve the results from. To test your code, simply log the results to the console.</p>
<pre><code class="language-typescript">// client/src/scenes/graph/GraphScene

import React, { useEffect, useRef } from &quot;react&quot;;
import { useApi } from &quot;../../hooks/UseApi&quot;;
import { Graph } from &quot;./components/Graph&quot;;

export const GraphScene = () =&gt; {
  const api = useApi();
  const graphRef = useRef&lt;Graph&gt;();

  useEffect(() =&gt; {
    // Exercise: Using the api, call the fetchGraph method. Since this returns a promise,
    // we need to use the `then` method to retrieve the results. With the results, call
    // `graphRef.current.createGraph` and add a console.log statement so you see the graph.
  }, []);

  return (
    &lt;div className=&quot;container-fluid h-100&quot;&gt;
      &lt;div className=&quot;row h-100&quot;&gt;
        &lt;div className=&quot;col h-100&quot;&gt;{&lt;Graph ref={graphRef} /&gt;}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p>Dev Note: The <code>useEffect</code> hook has two arguments: a callback function and an array of variables that when changed will trigger the callback function. Providing an empty array means our callback function will only be called when the component mounts, which is the functionality we are looking for.</p>
<p>Dev Note: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a> are a mechanism for working with asynchronous operations. When a promise completes, the results are available in the <code>then</code> method.</p>
<p>When you refresh your browser, the background will now be gray but you won't yet see the graph yet. If you open your developer tools, you will see the graph output that you wrote with console.log!</p>
<p><img src="app1/../images/ch1_app_02.png" alt="Console with Graph" /></p>
<h2 id="graph-component-overview"><a class="header" href="#graph-component-overview">Graph Component Overview</a></h2>
<p>The <code>Graph</code> component, <code>client/src/scenes/graph/components/Graph</code>, is a bit different from a normal React component because it is encapsulating D3. Typically React is in charge of rendering the DOM. For this component, React will only control the SVG element. D3 will take control of the SVG element and render elements into it.</p>
<p>React interfaces with D3 via two methods on the component: <code>createGraph</code> and <code>updateGraph</code>. Each method takes information from our domain and converts it into objects that D3 can control and render.</p>
<p>For those familiar with React this may be a bit weird since we are transitioning from the declarative style of programming used by React and using imperative code to call these functions. If that's a little confusing, take a gander at <code>GraphScene</code> and <code>Graph</code>. Notice that <code>GraphScene</code> renders <code>Graph</code> as a child, but we use the <code>createGraph</code> method to push information into D3.</p>
<h2 id="exercise-creating-the-graph"><a class="header" href="#exercise-creating-the-graph">Exercise: Creating the Graph</a></h2>
<p>After loading the page, we don't yet see the graph because we haven't fully implemented the <code>createGraph</code> method in the <code>Graph</code> component. <code>createGraph</code> is responsible for converting our <code>Lnd.Graph</code> object into objects that can be used by D3.</p>
<p>As defined in <code>server/src/domain/lnd/LndRestTypes</code>, our <code>Lnd.Graph</code> object has two arrays: <code>nodes</code> and <code>edges</code>.</p>
<p>Each <code>Lnd.LightningNode</code> object has three properties that we will use:</p>
<ul>
<li><code>pub_key</code> - a string that is the unique identifier for the node</li>
<li><code>color</code> - the color of the node that is specified by the node operator</li>
<li><code>alias</code> - the friendly name of the node that is specified by the node operator</li>
</ul>
<p>Each <code>Lnd.ChannelEdge</code> object has three properties that we will use:</p>
<ul>
<li><code>channel_id</code> - the unique identifier for the channel</li>
<li><code>node1_pub</code> - the identifier for the first node, when sorted, of the channel</li>
<li><code>node2_pub</code> - the identifier for the second node, when sorted, of the channel</li>
</ul>
<p>Using this information we need to construct new objects that can be controlled by D3. We need to do this because D3 will store rendering state on the objects. We don't want D3 to mutate the original objects so we'll construct new ones that D3 can control.</p>
<p>This gets us to our next exercise. We need to modify the <code>Graph</code> component's <code>createGraph</code> method to convert our Lightning graph objects into D3 controlled objects. To do this we create two arrays:</p>
<ul>
<li>one array for the graph's nodes created from our <code>Lnd.LightningNode</code>. We map <code>pub_key</code> to <code>id</code>, map <code>color</code> to <code>color</code>, and map <code>alias</code> to <code>title</code>.
<pre><code class="language-typescript">interface D3Node {
  id: string;
  color: string;
  title: string;
}
</code></pre>
</li>
<li>one array for the graph's links created from our <code>Lnd.ChannelEdge</code>. We map <code>channel_id</code> to <code>id</code>, <code>node1_pub</code> to <code>source</code> and <code>node2_pub</code> to <code>target</code>.
<pre><code class="language-typescript">interface D3Link {
  id: string;
  source: string;
  target: string;
}
</code></pre>
</li>
</ul>
<pre><code class="language-typescript">// client/src/scenes/graph/components/Graph

    createGraph(graph: LightningGraph) {
        // map the graph's nodes into d3 nodes
        this.nodes = [];

        // map the graph's channels into d3 links
        this.links = [];
</code></pre>
<p>Once we have created these maps we can refresh our browser and we should see the current graph!</p>
<p><img src="app1/../images/ch1_app_03.png" alt="Graph" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-time-server-updates"><a class="header" href="#real-time-server-updates">Real Time Server Updates</a></h1>
<p>At this point we've successfully connected our user interface to a REST server! However what happens if a new channel is created or a new node creates a channel? Our Lightning Network nodes will have new graph information but we would need to manually refresh the page.</p>
<p>Go ahead and give it a try by creating a channel between Bob and Carol. When we refresh the browser we should see a new link between Bob and Carol.</p>
<p>This is ok, but we can do better by passing updates to our user interface using WebSockets.</p>
<h2 id="exploring-websocket-code"><a class="header" href="#exploring-websocket-code">Exploring WebSocket Code</a></h2>
<p>The WebSocket code on our server uses the <a href="https://www.npmjs.com/package/ws">ws</a> library and lives inside the <code>SocketServer</code> class. You don't have to make any changes to it, but you may want to take a look at it. This class maintains a set of connected sockets. It also includes a <code>broadcast</code> method that allows us to send data for some channel to all connected sockets. We'll use this <code>broadcast</code> method shortly to send graph updates to all connected WebSockets.</p>
<p>The code to start the <code>SocketServer</code> lives inside <code>Server</code>. At the end of the <code>run</code> method, we create the <code>SocketServer</code> instance and have it listen to the HTTP server for connections.</p>
<pre><code class="language-typescript">// server/src/Server

async function run() {
    // OTHER CODE IS HERE...

  // start the server on the port
    const server = app.listen(Number(options.port), () =&gt; {
        console.log(`server listening on ${options.port}`);
    });

    // start the socket server
    const socketServer = new SocketServer();

    // start listening for http connections
    socketServer.listen(server);
</code></pre>
<p>All of this is ready to go, all we need to do is subscribe to updates from LND and do something with them.</p>
<h2 id="exercise-subscribe-to-updates"><a class="header" href="#exercise-subscribe-to-updates">Exercise: Subscribe to Updates</a></h2>
<p>Back in our server code's <code>LndGraphService</code> is a method <code>subscribeGraph</code> that we need to implement. This method subscribes to graph updates from LND using it's <code>subscribeGraph</code> method. The requirement for this function is that it needs to emit these updates as events.</p>
<pre><code class="language-typescript">  public async subscribeGraph(): Promise&lt;void&gt; {
    // Exercise: subscribe to the Lnd graph updates using `this.lnd.subscribeGraph`
    // and emit a &quot;update&quot; event each time the handler is called.
  }
</code></pre>
<p>Dev Note: This class is an <a href="https://nodejs.dev/learn/the-nodejs-event-emitter">EventEmitter</a>. EventEmitters can use the <code>emit</code> method to tell other classes that something has happened. These other classes are &quot;observers&quot; and can listen using the <code>on</code> method. Using EventEmitters allows us to keep code decoupled and avoid messy callback nesting.</p>
<h2 id="exploring-websocket-broadcasting"><a class="header" href="#exploring-websocket-broadcasting">Exploring WebSocket Broadcasting</a></h2>
<p>The next logical step is consuming the <code>update</code> event that we just created and sending the update to the client over a WebSocket. If you navigate back to the trusty <code>Server</code> you will find some interesting code at the bottom of the <code>run</code> function.</p>
<pre><code class="language-typescript">// server/src/Server

async function run() {
  // other code is here...

  // construct the socket server
  const socketServer = new SocketServer();

  // start listening for http connections using the http server
  socketServer.listen(server);

  // attach an event handler for graph updates and broadcast them
  // to WebSocket using the socketServer.
  graphAdapter.on(&quot;update&quot;, (update: Lnd.GraphUpdate) =&gt; {
    socketServer.broadcast(&quot;graph&quot;, update);
  });

  // subscribe to graph updates
  graphAdapter.subscribeGraph();
}
</code></pre>
<p>We subscribe to the <code>update</code> event on <code>graphAdapter</code> that we just implemented. In the event handler we then broadcast the update to all of the WebSockets.</p>
<p>After the event handler is defined, all of the plumbing is in place to for updates to go from <code>LND -&gt; LndRestClient -&gt; LndGraphAdapter -&gt; WebSocket</code>.</p>
<p>You should now be able to connect a WebSocket to the server and receive updates by generating channel opens or closes in Polar.</p>
<h1 id="real-time-user-interface"><a class="header" href="#real-time-user-interface">Real Time User Interface</a></h1>
<p>Now that our WebSocket server is sending updates, we need to wire these updates into our user interface.</p>
<h2 id="exploring-socket-connectivity"><a class="header" href="#exploring-socket-connectivity">Exploring Socket Connectivity</a></h2>
<p>The application already has some code to help us. We use React's context to establish a long-lived WebSocket that can be used by any component in the component hierarchy. This code lives in <code>client/src/context/SocketContext</code>.</p>
<p>To integrate this context into our components we can use a custom hook: <code>useSocket</code> that lives in <code>client/src/hooks/UseSocket</code>. This hook allows us to retrieve the websocket and subscribe to events for a any channel.</p>
<pre><code class="language-typescript">export const SomeComponent = () =&gt; {
  const socket = useSocket(&quot;some_channel&quot;, (data) =&gt; {
    // do something with data
    console.log(data);
  });
};
</code></pre>
<p>The last thing we should know is that in order for this to work, we need to establish the React Context higher in the component hierarchy. A great place is at the root!. We add the context via the <code>SocketProvider</code> component in our application's root component: <code>App</code>.</p>
<pre><code class="language-typescript">// client/src/App

import React from &quot;react&quot;;
import ReactDom from &quot;react-dom&quot;;
import { BrowserRouter } from &quot;react-router-dom&quot;;
import { SocketProvider } from &quot;./context/SocketContext&quot;;
import { LayoutScene } from &quot;./scenes/layout/LayoutScene&quot;;

ReactDom.render(
  &lt;SocketProvider&gt;
    &lt;BrowserRouter&gt;
      &lt;LayoutScene /&gt;
    &lt;/BrowserRouter&gt;
  &lt;/SocketProvider&gt;,
  document.getElementById(&quot;app&quot;)
);
</code></pre>
<p>With the lay of the land defined, we can now embark on our journey to finish the real time updates.</p>
<h2 id="exercise-subscribe-to-updates-1"><a class="header" href="#exercise-subscribe-to-updates-1">Exercise: Subscribe to Updates</a></h2>
<p>The logical place to subscribe to updates is in the <code>GraphScene</code> component. As previously established, this scene is responsible for wiring up data connections for graph related components.</p>
<p>Pointing our IDE at the <code>GraphScene</code> component our next exercise is implementing the socket handler. Using the <code>useSocket</code> hook, subscribe to <code>graph</code> channel. The handler function should call the <code>graphRef.current.updateGraph</code> method on the graph component.</p>
<pre><code class="language-typescript">// client/src/scenes/graph/GraphScene

import React, { useEffect, useRef } from &quot;react&quot;;
import { useSocket } from &quot;../../hooks/UseSocket&quot;;
import { useApi } from &quot;../../hooks/UseApi&quot;;
import { Graph } from &quot;./components/Graph&quot;;

export const GraphScene = () =&gt; {
  const api = useApi();
  const graphRef = useRef&lt;Graph&gt;();

  useEffect(() =&gt; {
    api.fetchGraph().then((graph) =&gt; {
      console.log(&quot;received graph&quot;, graph);
      graphRef.current.createGraph(graph);
    });
  }, []);

  useSocket(&quot;graph&quot;, (update: Lnd.GraphUpdate) =&gt; {
    // Exercise: Call `graphRef.current.updateGraph` with the update
  });

  return (
    &lt;div className=&quot;container-fluid h-100&quot;&gt;
      &lt;div className=&quot;row h-100&quot;&gt;
        &lt;div className=&quot;col h-100&quot;&gt;{&lt;Graph ref={graphRef} /&gt;}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<h2 id="exercise-update-the-graph"><a class="header" href="#exercise-update-the-graph">Exercise: Update the Graph</a></h2>
<p>We are almost done! The final step is completing the <code>updateGraph</code> method. This method converts our <code>Lnd.GraphUpdate</code> object into <code>D3Node</code> and <code>D3Link</code> objects.</p>
<p>The <code>Lnd.GraphUpdate</code> object we receive from the server is defined in <code>server/src/domain/lnd/LndRestTypes</code>. It consists of four pieces of data that we care about:</p>
<ol>
<li>new nodes that are don't yet have in the graph</li>
<li>existing nodes that need to have their title and alias updated</li>
<li>new channels that we need to add to the graph</li>
<li>closed channels that we need to remove from the graph</li>
</ol>
<p>The <code>updateGraph</code> method is partially implemented for the first three conditions. Your last task is to remove a channel from the links if it has been closed.</p>
<pre><code class="language-typescript">// client/src/scenes/graph/components/Graph

  updateGraph(update: Lnd.GraphUpdate) {
      // Updates existing nodes or adds new ones if they don't already
      // exist in the graph
      for (const nodeUpdate of update.result.node_updates) {
          const node = this.nodes.find(p =&gt; p.id === nodeUpdate.identity_key);
          if (node) {
              node.title = nodeUpdate.alias;
              node.color = nodeUpdate.color;
          } else {
              this.nodes.push({
                  id: nodeUpdate.identity_key,
                  color: nodeUpdate.color,
                  title: nodeUpdate.alias,
              });
          }
      }

      // Adds new channels to the graph. Note that for the purposes of
      // our visualization we only care that a link exists. We will end
      // up receiving two updates, one from each node and we just add
      // the first one.
      for (const channelUpdate of update.result.channel_updates) {
          const channel = this.links.find(p =&gt; p.id === channelUpdate.chan_id);
          if (!channel) {
              this.links.push({
                  source: channelUpdate.advertising_node,
                  target: channelUpdate.connecting_node,
                  id: channelUpdate.chan_id,
              });
          }
      }

      // Exercise: Remove closed channels from `this.links`.

      this.draw();
  }
</code></pre>
<p>After completing this exercise we will have everything needed for our graph to be functional. Try adding or removing a channel, you should see our graph application automatically update with the changes! Keep in mind that it may take a moment for changes to propagate throughout your network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="further-exploration"><a class="header" href="#further-exploration">Further Exploration</a></h1>
<p>This is just the beginning of interesting things we can do to help us visualize the Lightning Network. Hopefully this tutorial provided you with an overview of how we can interface with a Lightning Network node to retrieve information and receive real time updates.</p>
<p>A few ideas for how you can continue your exploration:</p>
<ul>
<li>How would you add other information to our user interface? What part of the application needs to be changed?</li>
<li>How would you connect to c-lightning or Eclair? What would need to change about the architecture?</li>
<li>How would you connect to testnet or mainnet? How would you address scaling given that the main network has 10's of thousands of nodes and channels?</li>
<li>How would you make our application production ready? How would you add testing? What happens if LND restarts? What happens if the REST/WebSocket server restarts?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lightning-network-invoices"><a class="header" href="#lightning-network-invoices">Lightning Network Invoices</a></h1>
<p>Receiving payments through invoices is one of the most common activities for Lightning applications. You're most likely already familiar with receiving payments via Bitcoin through an address. The Lightning Network handles payments in a different manner. The primary mechanism for receiving payments is through an invoice, also known as a payment request. In the most common use case a payment request is generated by the recipient and is provided out-of-band to the payment sender. The request is a one-time use thing that expires after some duration.</p>
<p>For example, Alice runs a web store and Bob wants to buy a t-shirt. He adds the shirt to his cart and goes to check out. At this point, Alice creates an invoice for Bob's purchase. This invoice includes the cost of the shirt, a timeout that Bob needs to complete the transaction within, the hash of a secret value generated by Alice, and Alice's signature denoting that she indeed created the payment request.</p>
<p>Based on the information encoded in the invoice, invoices are typically one-time use and are intended for a specific purpose and amount. Functionally, this means that an invoices tells the sender: who, how much, and within what time frame to send a payment. The invoice is also digitally signed by the recipient. The signature ensures that an invoice can't be forged (Carol can't create an invoice for Alice). The last and possibly most important piece is that the invoice includes the hash of secret information. This hash obscures the secret information that will only get revealed once a payment is made.</p>
<p>So when Bob pays the invoice and Alice receives the payment, she reveals the secret. Revealing this secret acts as a proof of payment. Alice would only ever reveal the secret if Bob has made payment. Bob can only possess the secret if Alice gives it to him. Bob also has a signed invoice from Alice stating the conditions of the transaction. So once Bob pays Alice and she reveals the secret, Bob has a signed message from Alice and the secret that he can use as proof of payment.</p>
<p>So why all this complexity?</p>
<p>It enables one of the primary purposes of the of the Lightning Network which is trustless payment flow. This scheme allows payments to flow through the network even if Bob and Alice aren't directly connected. If you're unsure on how this works or want a refresher, I recommend reading this article on <a href="https://medium.com/@peter_r/visualizing-htlcs-and-the-lightning-networks-dirty-little-secret-cb9b5773a0">HTLCs payments</a>.</p>
<p>For a more thorough walk through of invoices, check out Chapter 15 of <em>Mastering the Lightning Network</em> by Antonopoulos et al.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-setup-1"><a class="header" href="#environment-setup-1">Environment Setup</a></h1>
<p>Before we get started with invoices we first need to get our environment setup again. This application uses the same template we used in the Graph exercise, so you should already be familiar with the structure. For this application we'll only be focusing on building logic inside the <code>server</code> sub-project.</p>
<p>The application code is available in the <a href="https://github.com/bmancini55/building-lightning-invoices">Building on Lightning Invoices Project</a> on GitHub. To get started, you can clone this repository:</p>
<pre><code>git clone https://github.com/bmancini55/building-lightning-invoices.git
</code></pre>
<p>Navigate to the repository:</p>
<pre><code>cd building-lightning-invoices
</code></pre>
<p>The repository uses <code>npm</code> scripts to perform common tasks. To install the dependencies, run:</p>
<pre><code>npm install
</code></pre>
<p>This will install all of the dependencies for the three sub-modules in the project: <code>client</code>, <code>server</code>, and <code>style</code>. You may get some warnings, but as long as the install command has exit code 0 for all three sub-projects you should be good. If you do encounter any errors, you can try browsing to the individual sub-project and running the <code>npm install</code> command inside each directory.</p>
<p>We'll also need a Lightning Network environment to test. You can use the existing environment you created with Polar in the first project.</p>
<p>We'll again be building the application from the perspective of Alice using an LND node.</p>
<h2 id="exercise-configuring-env-to-connect-to-lnd-1"><a class="header" href="#exercise-configuring-env-to-connect-to-lnd-1">Exercise: Configuring <code>.env</code> to Connect to LND</a></h2>
<p>We'll again use the <code>dotenv</code> package to simplify environment variables.</p>
<p>You'll need to add some values to the <code>.env</code> inside the <code>server</code> sub-project. Specifically we'll set values for the following:</p>
<ul>
<li><code>LND_RPC_HOST</code> is the host for LND RPC</li>
<li><code>LND_ADMIN_MACAROON_PATH</code> is the file path to the admin Macaroon</li>
<li><code>LND_INVOICE_MACAROON_PATH</code> is the file path to the invoice Macaroon</li>
<li><code>LND_READONLY_MACAROON_PATH</code> is the file path to the &quot;readonly&quot; Macaroon</li>
<li><code>LND_CERT_PATH</code> is the certificate we use to securely connect with LND</li>
</ul>
<p>Optionally, you can also set the <code>LND_REST_HOST</code> value.
It's not necessary for this tutorial, but if you want to experiment with the REST API via the <code>building-lightning-invoices</code> repo, you will need it.</p>
<p>To populate these values navigate to Polar. To access Alice's node by clicking on Alice and then click on the <code>Connect</code> tab. You will be shown the information on how to connect to the GRPC and REST interfaces. Additionally you will be given paths to the network certificates and macaroon files that we will need in <code>.env</code>.</p>
<p><img src="app2/../images/ch1_polar_connect_to_alice.png" alt="Connect to Alice" /></p>
<p>Go ahead and add the environment variables defined above to <code>.env</code>.</p>
<pre><code># Express configuration
PORT=8001

# LND configuration
# Exercise: Provide values for Alice's node
LND_REST_HOST=
LND_RPC_HOST=
LND_CERT_PATH=
LND_ADMIN_MACAROON_PATH=
LND_INVOICE_MACAROON_PATH=
LND_READONLY_MACAROON_PATH=
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-an-invoice-in-code"><a class="header" href="#creating-an-invoice-in-code">Creating an Invoice in Code</a></h1>
<p>We'll start the invoice coding journey by doing a very simple script to create the invoice. When run, our script will simply call the <a href="https://api.lightning.community/#addinvoice"><code>AddInvoice</code></a> GRPC API in LND to construct and return the invoice.</p>
<p>The script code is located in <code>server/scripts/CreateInvoiceScript.ts</code> if you want to see the full thing. The interesting bits are below:</p>
<pre><code class="language-typescript">async function run() {
  // construct the options
  const options = await Options.fromEnv();

  // create the rpc client
  const lndRpcClient = new LndRpcClient(
    options.lndRpcHost,
    options.lndAdminMacaroon,
    options.lndCert
  );

  // create the invoice
  return lndRpcClient.addInvoice({
    memo: &quot;Demo invoice&quot;,
    amt: 1000,
  });
}
</code></pre>
<p>You can see this script has three parts</p>
<ol>
<li>Load the environment variables from the .env file we populated with Alice's node information</li>
<li>Construct a client to securely communicate with the LND node</li>
<li>Call the <code>AddInvoice</code> API with some info</li>
</ol>
<p>When the script is run it will output result from calling <code>AddInvoice</code> which includes the encoded payment request.</p>
<h2 id="exercise-run-the-create-script"><a class="header" href="#exercise-run-the-create-script">Exercise: Run the Create Script</a></h2>
<p>To run the script, from the root of repository, run the command:</p>
<pre><code>npm run script:create-invoice
</code></pre>
<p>Dev note: We're using an NPM script to help simplify running the script. When an NPM script runs it will first output the underlying command that it is trying to execute.</p>
<p>If you are successful you should see some output similar to:</p>
<pre><code>$ npm run script:create-invoice

&gt; building-lightning-invoices@1.0.0 script:create-invoice
&gt; cd server; ts-node scripts/CreateInvoiceScript.ts

{
  r_hash: &lt;Buffer 8f 9b 82 eb be 48 63 46 e5 6a 06 a0 e0 cd 18 e3 70 49 76 3d a3 23 d2 79 e8 3f d9 7d 7e 26 d3 44&gt;,
  payment_request: 'lnbcrt10u1p309sufpp537dc96a7fp35det2q6swpngcudcyja3a5v3ay70g8lvh6l3x6dzqdq5g3jk6meqd9h8vmmfvdjscqzpgsp59fj97cj6wcdlht8twr9ay3mhcm39nnfv8tp632lram4sxaylfwtq9qyyssqqll2xf39v9nwfy4pwlx8vl4wu6rxym56z80rylssu85h587kgssnleva78jwnz4lv0p9dhcka7pxgyh6hj462gzh897exa4ry4w4gfgqnzwpu8',
  add_index: '22',
  payment_addr: &lt;Buffer 2a 64 5f 62 5a 76 1b fb ac eb 70 cb d2 47 77 c6 e2 59 cd 2c 3a c3 a8 ab e3 ee eb 03 74 9f 4b 96&gt;
}
</code></pre>
<p>You can now copy the <code>payment_request</code> value and try to pay with Bob in Polar.</p>
<p><img src="app2/../images/ch2_app_bob_pays.png" alt="Bob Pays Invoice" /></p>
<p>As you can see, creating an invoice is pretty straight forward. This example relies on the node to create the preimage and the hash for the invoice. Try modifying the script to change the memo, amount, or creating a preimage.</p>
<p>Next we'll build a more complicated application using invoices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-walk-through"><a class="header" href="#application-walk-through">Application Walk-Through</a></h1>
<p>To keep things simple, the application we're going to create relies solely on our Lightning Network node. Instead of using a database system like PostgreSQL, we'll use the invoice database that is part of our node to keep track of the application state.</p>
<p>For our application we're going to use the Lightning Network and invoices to create a virtual game of <a href="https://en.wikipedia.org/wiki/King_of_the_Hill_(game)">king of the hill</a>. To play the game, someone becomes the leader by paying an invoice. Someone else can become the leader by paying a new invoice for more than the last leader. The neat thing is that any leader along the way can cryptographically prove they were the leader. In a sense, this application will act as a simple provenance chain for a &quot;digital right&quot; using Lightning Network invoices.</p>
<p>Let's see what our game looks like. Alice is running our application and is using LND as the backend. Bob is also running a network node and accesses Alice's website. Bob wants to become the first leader in the game.</p>
<p><img src="app2/../images/ch2_app_01.png" alt="Initial App" /></p>
<p>The application is prompting Bob that he will need to pay 1000 satoshis. But to do this he must sign a message using his Lightning Network node. In this case, Bob needs to digitally sign the message <code>0000000000000000000000000000000000000000000000000000000000000001</code>.
<img src="app2/../images/ch2_app_02.png" alt="Bob Signs" /></p>
<p>Note: In Polar we can open a terminal by right-clicking on the node and selecting &quot;Launch Terminal&quot;. With c-lightning, you can use the command <code>signmessage</code> to sign a message. It will return a signature in both hex and zbase32 formats. To simplify our application we'll use the zbase32 format since LND only interprets signatures in this format.</p>
<p>Now that Bob has a signature for the message, he provides the signature to the application's user interface. The server creates an invoice using Alice's Lightning Network node. This invoice is specific to Bob since he provided the signature. Alice's server returns the invoice to Bob via the user interface.</p>
<p><img src="app2/../images/ch2_app_03.png" alt="Bob Invoice" /></p>
<p>At this point, Bob can pay the invoice.</p>
<p><img src="app2/../images/ch2_app_04.png" alt="Bob Pays" /></p>
<p>Once Bob has paid the invoice he is now the new leader of the game!</p>
<p><img src="app2/../images/ch2_app_05.png" alt="Bob is the Leader" /></p>
<p>If Carol wants to become the new leader, she can sign the message <code>9c769de3f07d527b7787969d8f10733d86c08b253d32c3adc7067f22902f6f38</code> using her Lightning Network node.</p>
<p><img src="app2/../images/ch2_app_06.png" alt="Carol Signs" /></p>
<p>Note: In Polar, we once again can use the &quot;Launch Terminal&quot; option. With LND, you can also use the CLI command <code>signmessage</code>. This will only return a zbase32 format signature, which is the format our application requires.</p>
<p>Carol provides this signature via the user interface and the Alice's server generates an invoice specifically for Carol to become the leader of the game at point <code>9c769de3f07d527b7787969d8f10733d86c08b253d32c3adc7067f22902f6f38</code>.</p>
<p><img src="app2/../images/ch2_app_07.png" alt="Carol Invoice" /></p>
<p>When Carol pays the invoice she will become the new leader!</p>
<p><img src="app2/../images/ch2_app_08.png" alt="Carol Leader" /></p>
<p>Now that you have an understanding of how our application functions, we'll go through the algorithm for how it works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-algorithm"><a class="header" href="#application-algorithm">Application Algorithm</a></h1>
<p>You've now seen an example of our application with Bob and Carol becoming the leaders. This section will dig into the details of how the application works.</p>
<p>In order to create the ownership chain we're going to use a combination of hashes and digital signatures. We'll do a quick overview of both of those cryptographic primitives.</p>
<h2 id="cryptographic-hash-functions"><a class="header" href="#cryptographic-hash-functions">Cryptographic Hash Functions</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Hash_function">Hash functions</a> are functions that map data of arbitrary size to a fixed size. A <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash function</a> is a hash function that is a one-way function who result is indistinguishable from random. A one-way function is a function where it is easy to compute in one direction but it is extremely difficult to compute the inverse function. For example, given a function <code>f(x) =&gt; y</code>, <code>y</code> is easy to generate given the function <code>f</code> and input <code>x</code>. However it is extremely difficult (and for good CHFs intractable) to calculate <code>x</code> given only <code>y</code> and <code>f</code>.</p>
<p>In terminology, the input to a hash function is known as a <strong>preimage</strong>. When the preimage is run through the hash function it produces a <strong>digest</strong>.</p>
<p>Bitcoin and Lightning Network frequently use the SHA-256 hash function. This function results in a 32-byte (256-bit) output. For example, if we use the SHA-256 hash algorithm we can see the 32-byte hex encoded digest.</p>
<pre><code>sha256(&quot;a&quot;) = ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb
sha256(&quot;b&quot;) = 3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d
</code></pre>
<p>As we discussed, there is no way to to derive the preimage <code>a</code> given the digest <code>ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb</code> or to derive the preimage <code>b</code> given the digest <code>3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d</code>.</p>
<p>If we combine the preimages to make <code>ab</code> we get a new digest that is in no way related to the digests of the individual preimage components.</p>
<pre><code>sha256(&quot;ab&quot;) = fb8e20fc2e4c3f248c60c39bd652f3c1347298bb977b8b4d5903b85055620603
</code></pre>
<p>Cryptographic hash functions enable us to do interesting things like hide information in the digest that can be verified with knowledge of the preimage. We see this in action with invoices and HTLC payments. We'll leverage this information hiding/revealing to selectively build the preimage for our hash.</p>
<h2 id="elliptic-curve-digital-signature-algorithm-ecdsa"><a class="header" href="#elliptic-curve-digital-signature-algorithm-ecdsa">Elliptic Curve Digital Signature Algorithm (ECDSA)</a></h2>
<p>This application will also make use of digital signatures created using the elliptic curve digital signature algorithm over the curve secp256k1. This is the curve that Bitcoin and Lightning Network use for digital signatures. We're not going to get into the specifics of how digital signatures work but if you want to deep dive, I recommend reading Chapters 1-3 of <em>Programming Bitcoin</em> by Jimmy Song.</p>
<p>The quick hits are that a private key can be used to generate a public key. This public key can be public knowledge. Only the holder of the private key is capable of generating the public key.</p>
<p>A signature is created for some piece of data, we'll refer to it as <code>z</code> using the private key. The signature can be shared publicly.</p>
<p>When a signature is combined with a public key it can be used to verify that the signature was indeed created by owner of that public key.</p>
<p>Given just the signature (and a bit of extra metadata), it is also possible to derive the public key that was used to create the signature. When a Lightning Network node verifies a signature it will derive the public key from the signature and verify it against the network graph database that contains all of the public keys for the network. We'll be using signature creation and validation in our application.</p>
<h2 id="our-algorithm"><a class="header" href="#our-algorithm">Our Algorithm</a></h2>
<p>In our application we'll be using both digital signature and hashes to construct a chain of ownership. The basis of this chain is that the preimage from the last-settled invoice is used as an identifier of the next link. In a sense this creates a hash-chain of ownership.</p>
<p><img src="app2/../images/ch2_diagram_01.png" alt="Basic Links" /></p>
<p>This diagram shows you that the first link starts with some arbitrary id, in this case <code>id=0</code>. We start with an arbitrary identifier because there was no prior state. In each link, many invoices can be generated using this identifier. Each invoice will have a unique preimage that ties it to the user that wants to pay the invoice. When an invoice is finally paid (say with <code>preimage=X</code> for instance) a new link is generated and the identifier of the new link becomes the preimage of the settled invoice (so <code>id=X</code> for this example). So as you can see, when an invoice is paid, its preimage becomes identifier of our application.</p>
<p>Unlike in simple invoice payments (that we saw earlier), the preimage is not going to be arbitrarily generated by our Lightning Network node. We need to tie each invoices to a specific users for the current state of the game. We need to ensure that:</p>
<ol>
<li>Each invoice in a link has a unique preimage and hash, eg if Alice and Bob both want to become the leader they should get different invoices.</li>
<li>It is not possible to guess the preimage for an invoice</li>
<li>A leader can reconstruct the preimage using information that only they can generate once a payment has been made. This provides proof of ownership beyond possession of the preimage.</li>
</ol>
<p>So let's explore the actual construction.</p>
<p>Alice is running the server for our application. She initiates the service with some <code>seed</code> value. Alice signs a message with the <code>seed</code> and keeps her signature to herself for now. Alice can always easily regenerate this signature if she needs to by resigning the <code>seed</code>.</p>
<p>Bob accesses Alice's website, and discovers that he can become the leader by</p>
<ol>
<li>Creating a signature using his Lightning Network node where the message is the <code>seed</code></li>
<li>Sending this signature to Alice's application</li>
</ol>
<p>Alice's application verifies Bob's signature, making sure it is a valid signature for the <code>seed</code> and she sees that it's from Bob. As we talked about, only Bob will be able to generate this signature, but anyone can verify that the signature is valid and from Bob.</p>
<p>Alice now creates an invoice preimage by concatenating her signature for the <code>seed</code>, Bob's signature for the <code>seed</code>, and the satoshis that Bob is willing to pay.</p>
<pre><code>preimage = alice_sig(seed) || bob_sig(seed) || satoshis
</code></pre>
<p>The only issue is that the Lightning Network invoices require the preimage to be 32-bytes. We get around this by simply using hashing to contain the value within 32-bytes:</p>
<pre><code>preimage = sha256(alice_sig(seed) || bob_sig(seed) || satoshis)
</code></pre>
<p>Then our hash digest in the invoice is the hash of the preimage:</p>
<pre><code>hash = sha256(preimage)
hash = sha256(sha256(alice_sig(seed) || bob_sig(seed) || satoshis))
</code></pre>
<p>Alice sends Bob the invoice. Bob wants to take ownership, so he pays the invoice and receives the preimage as proof of payment.</p>
<p>At this point, Bob can prove that he paid the invoice since he has the preimage, but he can't reconstruct the preimage. Alice needs to publish her signature to the website for Bob to be able reconstruct the preimage. Ideally we would have a scheme where Bob can prove ownership without needing out-of-band information, something encoded directly in the preimage itself. A fun thought experiment for later.</p>
<p>So how does Carol take over ownership? In order to do this, Alice application now advertises Bob's preimage as the current state. Carol can sign Bob's preimage and perform the same upload/pay invoice that Bob did. Once she completes the payment, the preimage for Carol's paid invoice becomes the new leading state of the game.</p>
<p>Now that may be a lot to unpack, so you may want to go through it a few time. And don't worry, after a few goes at making Bob and Carol the leaders it will hopefully become more intuitive.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-invoice-class"><a class="header" href="#creating-the-invoice-class">Creating the <code>Invoice</code> Class</a></h1>
<p>The next logical step is configuring how we'll handle invoices. For this application, we'll use LND and its invoice database to power our application. We'll be encoding some basic information into the invoice memo field so our application doesn't need to maintain or synchronize a separate database. In a production system we'd likely use a separate database system, but we've made this decision to keep the application tightly focused.</p>
<p>This time around we'll be using the <a href="https://api.lightning.community/#lnd-grpc-api-reference">LND RPC API</a>. This is similar to the REST interface we used in the previous application but uses a binary protocol instead of HTTPS to communicate with the LND node. For the purposes of our application it will be remarkably similar and in reality, the only difference will be how we wire up the application. Which brings us to our next point.</p>
<p>From a software engineering perspective, it's a good practice to isolate our application logic from the specifics of the underlying data persistence mechanism. This rule is often conveyed when working with relational databases systems where it would be poor form for your database tables to dictate how your application logic functions. This is no different than working with Lightning Network nodes! We break out our code so that we can tightly focus the critical application bits from the logic of how we retrieve that information. A by-product is that we could switch from LND to c-lightning or Eclair without having to change our core application logic!</p>
<p>To achieve this decoupling, instead of pinning our application to the structure of invoices in LND's database, we'll create our own <code>Invoice</code> type that is used throughout our application. This also allows us to add some methods to our <code>Invoice</code> type that are domain specific to our application.</p>
<p>You can take a look at the <code>server/domain/Invoice</code> class. This class only has properties that the application uses: memo, preimage, hash, value in satoshis, and settlement information.</p>
<pre><code class="language-typescript">export class Invoice {
  constructor(
    public memo: string,
    public preimage: string,
    public hash: string,
    public valueSat: string,
    public settled: boolean = false,
    public settleDate?: number
  ) {}

  // Methods not shown...
}
</code></pre>
<h2 id="exercise-implement-creatememo"><a class="header" href="#exercise-implement-creatememo">Exercise: Implement <code>createMemo</code></a></h2>
<p>Our application is going be encoding some information into the memo field. We need to be careful about making the memo field too large but for our applications sake we'll construct the memo as such:</p>
<pre><code>buy_{linkId}_{buyerId}
</code></pre>
<p>The <code>linkId</code> is going to be a 32-byte value (64 hex encoded characters). As we discussed in the last section, the linkId is the current point of the game. We use the <code>linkId</code> to help us identify which point of the game the invoice was for.</p>
<p>The <code>buyerId</code> is the 33-byte public key (66 hex encoded characters) of the node that we are generating the invoice for. In this case, if Bob requested an invoice to pay, this value would be the public key of Bob's Lightning Network node.</p>
<p>Go ahead and implement the <code>createMemo</code> method in <code>server/domain/Invoice</code> class according to the rule specified.</p>
<pre><code class="language-typescript">public static createMemo(linkId: string, buyer: string) {
    // Exercise
}
</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep createMemo
</code></pre>
<h2 id="helper-function-isappinvoice"><a class="header" href="#helper-function-isappinvoice">Helper Function <code>isAppInvoice</code>.</a></h2>
<p>Now that you create invoices memos we'll need to do the inverse. We need a way to distinguish invoices that the application created from other invoices that the Lightning Network node may have created for other purpose.</p>
<p>We do this with the <code>isAppInvoice</code> method. This method checks whether the memo conforms to the pattern we just created in the <code>createMemo</code> method. This function will only return true when a few conditions have been met:</p>
<ol>
<li>The invoice's memo field starts with the prefix <code>buy_</code></li>
<li>The invoice's memo then contains 64 hex characters followed by another underscore</li>
<li>The invoice's memo ends with 66 hex characters.</li>
</ol>
<pre><code class="language-typescript">public isAppInvoice(): boolean {
    return /^buy_[0-9a-f]{64}_[0-9a-f]{66}$/.test(this.memo);
}
</code></pre>
<h2 id="helper-functions-linkid-and-buyernodeid"><a class="header" href="#helper-functions-linkid-and-buyernodeid">Helper Functions <code>linkId</code> and <code>buyerNodeId</code></a></h2>
<p>We have two more helper methods that will be useful for our application. We want a quick way to extract the link identifier and the buyer's public key from the memo. We'll do this by implementing two helper methods that grab these values from the memo field. These two methods are very similar.</p>
<pre><code class="language-typescript">public get linkId(): string {
    return this.memo.split(&quot;_&quot;)[1];
}

public get buyerNodeId(): string {
    return this.memo.split(&quot;_&quot;)[2];
}
</code></pre>
<h2 id="exercise-implement-createpreimage"><a class="header" href="#exercise-implement-createpreimage">Exercise: Implement <code>createPreimage</code></a></h2>
<p>The last method we'll need on the <code>Invoice</code> class is a helper method that allows us to construct the preimage for an invoice. If you recall that we're going to generate the preimage using three pieces of data:</p>
<ol>
<li>The server's signature of the current link identifier</li>
<li>A signature of the current link identifier created by the person trying to become the leader</li>
<li>The satoshis that they will pay to become the leader.</li>
</ol>
<p>We concatenate these values and use <code>sha256</code> to contain the concatenation inside 32-bytes. Our algorithm looks like:</p>
<pre><code>sha256(alice_sig(seed) || bob_sig(seed) || satoshis)
</code></pre>
<p>where <code>||</code> denotes concatenation.</p>
<p>Based on that information, go ahead and implement the <code>createPreimage</code> method in the <code>server/domain/Invoice</code> class. Note that a <code>sha256</code> function is available for you to use.</p>
<pre><code class="language-typescript">public static createPreimage(local: string, remote: string, sats: number) {
    // Exercise
}
</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep createPreimage
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-invoices"><a class="header" href="#loading-invoices">Loading Invoices</a></h1>
<p>Now that we've discussed some aspects of domain specific invoices, we need to connect to our Lightning Network node and load invoices from its database. Our application does this using the <a href="https://martinfowler.com/eaaCatalog/dataMapper.html">data mapper</a> design pattern to isolate the specifics about data access from the remainder of our application logic.</p>
<p>We define our data access behavior in the <code>IInvoiceDataMapper</code> interface that contains two methods for adding an invoice and performing a synchronization with the database.</p>
<pre><code class="language-typescript">export interface IInvoiceDataMapper {
  /**
   * Adds an invoice to the Lightning Network node
   */
  add(value: number, memo: string, preimage: Buffer): Promise&lt;string&gt;;

  /**
   * Synchronizes the application with the current state of invoices. The
   * handler method will be called for each invoice found in the invoice
   * database and will be called when a new invoice is created, settled,
   * or changes.
   */
  sync(handler: InvoiceHandler): Promise&lt;void&gt;;
}

/**
 * Defines a callback function that can be used to process a found invoice.
 */
export type InvoiceHandler = (invoice: Invoice) =&gt; Promise&lt;void&gt;;
</code></pre>
<p>With the <code>IInvoiceDataMapper</code> defined, we need to implement a concrete version of it that works with LND. The <code>LndInvoiceDataMapper</code> class does just that. It is located in the <code>server/data/lnd</code> folder. The constructor of this class accepts the interface <code>ILndClient</code>. There are two classes that implement <code>ILndClient</code>: <code>LndRestClient</code> and <code>LndRpcClient</code> that connect to LND over REST and GRPC respectively. We'll be using the latter to connect to LND over the GRPC API. With this code structure, our application could switch to other types of Lightning Network nodes by implementing a new <code>IInvoiceDataMapper</code>. Or if we wanted to switch between the LNDs REST or GRPC client we can supply a different <code>ILndClient</code> to the <code>LndInvoiceDataMapper</code>.</p>
<p>We'll now explore the methods on the <code>LndInvoiceDataMapper</code>. For loading invoices we're concerned with the <code>sync</code> method.</p>
<p>The <code>sync</code> method reaches out to our invoice database and requests all invoices. It will also subscribe to creation of new invoices or the settlement of existing invoices. Because the syncing process and the subscription are long lived, we will use notifications to alert our application code about invoice events instead of returning a list of the <code>Invoice</code> type. You may have noticed the <code>InvoiceHandler</code> type. This type defines any function that receives an <code>Invoice</code> as an argument. Our <code>sync</code> method takes a single argument which must be an <code>InvoiceHandler</code>. This handler function will be called every time an invoice of is found or changes.</p>
<p>The <code>sync</code> method does two things:</p>
<ol>
<li>connects to LND and retrieves all invoices in the database</li>
<li>subscribes to existing invoices for changes</li>
</ol>
<pre><code class="language-typescript">public async sync(handler: InvoiceHandler): Promise&lt;void&gt; {
    // fetch all invoices
    const num_max_invoices = Number.MAX_SAFE_INTEGER.toString();
    const index_offset = &quot;0&quot;;
    const results: Lnd.ListInvoiceResponse = await this.client.listInvoices({
        index_offset,
        num_max_invoices,
    });

    // process all retrieved invoices by calling the handler
    for (const invoice of results.invoices) {
        await handler(this.convertInvoice(invoice));
    }

    // subscribe to all new invoices/settlements
    void this.client.subscribeInvoices(invoice =&gt; {
        void handler(this.convertInvoice(invoice));
    }, {});
}
</code></pre>
<p>Looking at this code, you'll see that the method receives a <code>handler: InvoiceHandler</code> parameter and we call that handler for each invoice that our database returns and when there is a change as a result of the subscription.</p>
<p>But, before we call the handler we need to convert the invoice from LND's invoice to our application's <code>Invoice</code> type.</p>
<h2 id="exercise-implement-convertinvoice"><a class="header" href="#exercise-implement-convertinvoice">Exercise: Implement <code>convertInvoice</code></a></h2>
<p>This function is a mapping function that converts LND's invoice type into our application domain's <code>Invoice</code> class.</p>
<p>Go ahead and implement the <code>convertInvoice</code> method in the <code>server/data/LndInvoiceDataMapper</code> class. Make sure to perform proper type conversions.</p>
<pre><code class="language-typescript">public convertInvoice(invoice: Lnd.Invoice): Invoice {
    // Exercise
}
</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep convertInvoice
</code></pre>
<p>At this point our application has all the necessary pieces to retrieve and process invoices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-link-class"><a class="header" href="#creating-the-link-class">Creating the <code>Link</code> Class</a></h1>
<p>For our application, we can think of the leaders in the game as links in a chain. There is always a link at the end that is &quot;open&quot; for taking over the leadership position. The last closed link in the chain is the current leader of the game.</p>
<p>The <code>Link</code> class defines a single link in the chain of ownership. A <code>Link</code> can be in one of two states: <code>unsettled</code> or <code>settled</code>.</p>
<p>When a <code>Link</code> is unsettled, it means that no one has take ownership or closed that link. It is still open to the world and anyone can pay an invoice and take ownership. Only the last link in the chain will ever be <code>unsettled</code>.</p>
<p>When a <code>Link</code> is settled, it means there was an invoice that was paid to close that link. The person that paid the invoice becomes the owner of that link. The last closed link in the chain is considered the current leader of the game.</p>
<p>Take a look at the diagram of game links again.</p>
<p><img src="app2/../images/ch2_diagram_01.png" alt="Link" /></p>
<p>The preimage of a settled invoice of the <em>prior</em> link becomes the identifier of the next link.</p>
<p>Let's take a look at the <code>Link</code> type.</p>
<pre><code class="language-typescript">export class Link {
  public invoice: Invoice;

  constructor(
    public linkId: string,
    public localSignature: string,
    public minSats: number
  ) {}

  // Methods
}
</code></pre>
<p>This type has a few properties:</p>
<ul>
<li><code>linkId</code> is the identifier of the link and will either be a seed value for the first link or the preimage of the the settling invoice of the previous link.</li>
<li><code>localSignature</code> is our Lightning Network node's signature of the <code>linkId</code>. We'll use this to construct invoices using our <code>createPreimage</code> helper function</li>
<li><code>minSats</code> is the minimum satoshis payment we're willing to accept payment to settle this <code>Link</code>. This value will be larger than the last link.</li>
</ul>
<p>You'll also notice that there is an <code>invoice</code> property. This property will be assigned when a invoice when someone pays the <code>Invoice</code> that corresponds to this link.</p>
<h2 id="exercise-implement-issettled"><a class="header" href="#exercise-implement-issettled">Exercise: Implement <code>isSettled</code></a></h2>
<p>A <code>Link</code> is only considered settled when it has an invoice assigned and that invoice is settled.</p>
<p>Go ahead and implement the <code>isSettled</code> getter which should check the <code>invoice</code> property to see if it has a value. If it does have a value it should check the invoice to see if it has been settled.</p>
<pre><code class="language-typescript">public get isSettled(): boolean {
    // Exercise
}
</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep isSettled
</code></pre>
<h2 id="exercise-implement-nextlinkid"><a class="header" href="#exercise-implement-nextlinkid">Exercise: Implement <code>nextLinkId</code></a></h2>
<p>Once a <code>Link</code> is settled, the <code>nextLinkId</code> property should contain the settling invoice's preimage.</p>
<p>This property should only return a value when a <code>Link</code> is settled. When the <code>Link</code> is settled it should return the invoice's preimage.</p>
<p>Go ahead and implement the <code>nextLinkId</code> getter.</p>
<pre><code class="language-typescript">public get nextLinkId(): string {
    // Exercise
}
</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep nextLinkId
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-linkfactory-class"><a class="header" href="#creating-the-linkfactory-class">Creating the <code>LinkFactory</code> Class</a></h1>
<p>To help us construct links we'll use the <code>LinkFactory</code> class. This class is responsible for creating <code>Link</code> objects based on two common scenarios:</p>
<ol>
<li><code>createFromSeed</code> - creates the first link in the chain using a seed since we won't have a prior link.</li>
<li><code>createFromSettled</code> - creates a new &quot;tip of the chain&quot; link when someone closes / settles a Link using the last settled link.</li>
</ol>
<p>This class takes care of the heavy lifting for creating a <code>Link</code> so that we can easily test our code, and the consumers of this code aren't burdened by the implementation details of creating a <code>Link</code>.</p>
<p>As we previously talked about, we'll be using digital signatures. This class has a dependency on the <code>IMessageSigner</code> interface. This interface provides two methods:</p>
<ol>
<li>one for signing a message using your Lightning Network node</li>
<li>one for verifying a received signature</li>
</ol>
<pre><code class="language-typescript">export interface IMessageSigner {
  /**
   * Signs a message using the Lightning Network node
   */
  sign(msg: string): Promise&lt;string&gt;;

  /**
   * Verifies a message using the Lightning Network node
   */
  verify(msg: Buffer, signature: string): Promise&lt;VerifySignatureResult&gt;;
}
</code></pre>
<p>Under the covers, we have already implemented a <code>LndMessageSigner</code> class that uses LND to perform signature creation and verification. This will be wired up later but feel free to explore this code in the <code>server/data/lnd</code> folder.</p>
<h2 id="exercise-implement-createfromseed"><a class="header" href="#exercise-implement-createfromseed">Exercise: Implement <code>createFromSeed</code></a></h2>
<p>As we previously discussed, a <code>Link</code> starts out in the <code>unsettled</code> state, which means that no one has taken ownership of it. Logically, the application starts off without any ownership and in an <code>unsettled</code> state. Since we don't have any prior links, we'll simply create a link from some seed value.</p>
<p>In order to create a link we do two things:</p>
<ol>
<li>Sign the seed value using our Lightning Network node using the <code>IMessageSigner</code> instance</li>
<li>Construct a new <code>Link</code> and supply the seed as the <code>linkId</code>, the signature our application server made for the seed, and the starting satoshis value required for the first owner.</li>
</ol>
<p>Go ahead and implement the <code>createFromSeed</code> method.</p>
<pre><code class="language-typescript">public async createFromSeed(seed: string, startSats: number): Promise&lt;Link&gt; {
    // Exercise
}
</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep createFromSeed
</code></pre>
<h2 id="exercise-implement-createfromsettled"><a class="header" href="#exercise-implement-createfromsettled">Exercise: Implement <code>createFromSettled</code></a></h2>
<p>Now that we know how to create a link to start the application. A person could become the leader by paying the invoice. Once that invoice is paid, the first link will become settled. We need a method to create a <em>new</em> link so that the next person can try to become the leader.</p>
<p>We will create the <code>createFromSettled</code> method which will create the next <code>unsettled</code> link from a link that has been <code>settled</code>.</p>
<p>Instead of a seed, we'll use the <code>nextLinkId</code> property from the <code>Link</code>, which we implemented in the previous section, as the link's identifier.</p>
<p>The <code>createFromSettled</code> method will need to do three things:</p>
<ol>
<li>Use the <code>IMessageSigner.sign</code> method to sign the <code>nextLinkId</code> value using our Lightning Network node</li>
<li>Increment the minimum satoshis to +1 more than the settled invoice</li>
<li>Construct the new <code>unsettled</code> <code>Link</code></li>
</ol>
<p>Go ahead and implement the <code>createFromSettled</code> method.</p>
<pre><code class="language-typescript">public async createFromSettled(settled: Link): Promise&lt;Link&gt; {
    // Exercise
}
</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep createFromSettled
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-appcontroller-class"><a class="header" href="#creating-the-appcontroller-class">Creating the <code>AppController</code> Class</a></h1>
<p>Now that we have all the components built, we'll turn our attention to the primary logic controller for our application! This logic resides in the <code>AppController</code> class located in <code>server/domain</code>. This class is responsible for constructing and maintaining the chain of ownership based on paid invoices.</p>
<p>The constructor of this class takes a few things we've previously worked on such as:</p>
<ul>
<li><code>IInvoiceDataMapper</code> - we'll use this to create and fetch invoices from our Lightning Network node</li>
<li><code>IMessageSigner</code> - we'll use this validate signatures that we receive from remote nodes</li>
<li><code>LinkFactory</code> - we'll use this to create links in our ownership chain</li>
</ul>
<p>If you take a look at this class, you'll also notice that we have the <code>chain</code> property that maintains the list of <code>Link</code> in our application. This is where our application state will be retained in memory.</p>
<pre><code class="language-typescript">public chain: Link[];
</code></pre>
<p>There is also a conveniently added <code>chaintip</code> property that returns the last record in the chain.</p>
<pre><code class="language-typescript">public get chainTip(): Link {
    return this.chain[this.chain.length - 1];
}
</code></pre>
<p>One other note about our <code>AppController</code> is that it uses the <code>observer</code> pattern to notify a subscriber about changes to the chain. In this case the subscriber will be all of the open websockets. The observer will receive an array of changed <code>Link</code> whenever the chain changes. This can be found in the <code>listener</code> property on the <code>AppController</code> class.</p>
<pre><code> public listener: (info: Link[]) =&gt; void;
</code></pre>
<p>Dev Note: Why not use <code>EventEmitter</code>? Well we certainly could. Since this example only has a single event it's easy to bake in a handler/callback function for <code>Link</code> change events.</p>
<p>Lastly, this class will implement three functions that we'll discuss in more detail. These methods create a clean interface for our application logic to sit between external users (REST API and Websockets) and our Lightning Network node. These methods are:</p>
<ol>
<li><code>start</code> - this method is used to start the application and synchronize the game state with the invoices of a Lightning Network node</li>
<li><code>handleInvoice</code> - this method is used to check invoices that are received by the Lightning Network node</li>
<li><code>createInvoice</code> - constructs an invoice for the current <code>Link</code> based on information provided by some user.</li>
</ol>
<h2 id="starting-the-application"><a class="header" href="#starting-the-application">Starting the Application</a></h2>
<p>We should now have a general understanding of the <code>AppController</code> class. A great place to begin is how we start the application. We do this with the <code>start</code> method. This method is used to bootstrap our application under two start up scenarios:</p>
<ol>
<li>The first time the application is started</li>
<li>Subsequent restarts when we have some links in the chain</li>
</ol>
<p>In either case, we need to get the game state synchronized. The synchronization requires two steps:</p>
<ol>
<li>Create the first link using the <code>seed</code></li>
<li>Synchronize the application by looking at all of our Lightning Network node's invoices using <code>IInvoiceDataMapper</code></li>
</ol>
<p>Back when we discussed the <code>IInvoiceDataMapper</code> we had a <code>sync</code> method. If you recall, this method accepted an <code>InvoiceHandler</code> that defined a simple function that has one argument, an <code>Invoice</code>.</p>
<pre><code class="language-typescript">export type InvoiceHandler = (invoice: Invoice) =&gt; Promise&lt;void&gt;;
</code></pre>
<p>If you take a look at the <code>AppController</code>. You'll see that <code>handleInvoice</code> matches this signature! This is not a coincidence. We'll we use the <code>handleInvoice</code> method to process all invoices that our Lightning Network node knows about.</p>
<p>Now that we understand that, let's do an exercise and implement our <code>start</code> method.</p>
<h2 id="exercise-implement-start"><a class="header" href="#exercise-implement-start">Exercise: Implement <code>start</code></a></h2>
<p>To implement the <code>start</code> method requires us to perform two tasks:</p>
<ol>
<li>Use the <code>linkFactory</code> to create the first <code>Link</code> from the seed argument</li>
<li>Once the first link is created, initiate the synchronization of invoices using the <code>IInvoiceDataMapper</code> (as mentioned, provide the <code>AppController.handleInvoice</code> method as the handler).</li>
</ol>
<pre><code class="language-typescript">public async start(seed: string, startSats: number) {
    // Exercise
}
</code></pre>
<p>Dev Tip: One of the trickier aspects of JavaScript is scoping of <code>this</code>. Since the <code>handleInvoice</code> method will be used as a callback but it belongs to the <code>AppController</code> class, special care must be made to ensure that it does not lose scope when it is called by the <code>sync</code> method. You will have an issue if you provide it directly as an argument to the <code>sync</code> method: <code>await this.invoiceDataMapper.sync(this.handleInvoice);</code>. Doing this treats the <code>handleInvoice</code> method as an unbound function, which means any use of <code>this</code> inside of that function will be scoped to the caller instead of the <code>AppController</code> class instance.</p>
<p>You can retain scope of the <code>AppController</code> class instance in two ways:</p>
<ol>
<li>use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>bind</code></a> to bind the function to the desired scope. Eg: bind it to the current instance of the class <code>await this.invoiceDataMapper.sync(this.handleInvoice.bind(this))</code>.</li>
<li>use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"><code>arrow functions</code></a> which retain the scoping of the caller. Eg: <code>await this.invoiceDataMapper.sync(invoice =&gt; this.handleInvoice(invoice))</code>.</li>
</ol>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep AppController.*start
</code></pre>
<h2 id="exercise-implement-handleinvoice"><a class="header" href="#exercise-implement-handleinvoice">Exercise: Implement <code>handleInvoice</code></a></h2>
<p>Next on the docket, we need to process invoices we receive from our Lightning Network node. The <code>handleInvoice</code> is called every time an invoice is found, created, or fulfilled by our Lightning Network node. This method does a few things to correctly process an invoice:</p>
<ol>
<li>Checks if the invoice settles the current <code>Link</code>. Hint look at the <code>settles</code> method on the <code>Invoice</code>. If the invoice doesn't settle the current <code>Link</code>, no further action is required.</li>
<li>If the invoice does settle the current <code>Link</code>, it should call the <code>settle</code> method on <code>Link</code> which will settle the <code>Link</code>.</li>
<li>It should then create a new <code>Link</code> using the <code>LinkFactory.createFromSettled</code>.</li>
<li>It should add the new unsettled link to the application's chain</li>
<li>Finally, it will send the settled link and the new link to the listener.</li>
</ol>
<p>This method is partially implemented for you. Complete the method by settling the current link and constructing the next link from the settled link.</p>
<pre><code class="language-typescript">public async handleInvoice(invoice: Invoice) {
    if (invoice.settles(this.chainTip)) {
        const current = this.chainTip;

        // settle the current chain tip

        // create a new unsettled Link

        // add the new link to the chain

        // send settled and new to the listener
        if (this.listener) {
            this.listener([settled, nextLink]);
        }
    }
}
</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep AppController.*handleInvoice
</code></pre>
<h2 id="exercise-createinvoice"><a class="header" href="#exercise-createinvoice">Exercise: <code>createInvoice</code></a></h2>
<p>The last bit of code <code>AppController</code> is responsible for is creating invoices. This method is responsible for interacting with the Lightning Network node's message signature verification through the <code>IMessageSigner</code> interface. It will also interact with the Lightning Network node to create the invoice via the <code>IInvoiceDataMapper</code>.</p>
<p>Recall that when someone wants to take ownership of the current link they'll need to send a digital signature of the current <code>linkId</code>.</p>
<p>Our method does a few things:</p>
<ol>
<li>Verifies the signature is for the current <code>linkId</code>. If not, it returns a failure.</li>
<li>Constructs the preimage for the invoice. Recall that we implemented the <code>createPreimage</code> method on <code>Invoice</code> previously.</li>
<li>Constructs the memo for the invoice. Recall that we implemented the <code>createMemo</code> method on <code>Invoice</code> previously.</li>
<li>Creates the invoice using the <code>IInvoiceDataMapper.add</code> method.</li>
<li>Return a success or failure result to the caller.</li>
</ol>
<p>This method is partially implemented for you.</p>
<pre><code class="language-typescript">public async createInvoice(
    remoteSignature: string,
    sats: number,
): Promise&lt;CreateInvoiceResult&gt; {
    // verify the invoice provided by the user
    const verification = await this.signer.verify(this.chainTip.linkId, remoteSignature);

    // return failure if signature fails
    if (!verification.valid) {
        return { success: false, error: &quot;Invalid signature&quot; };
    }

    // Exercise: create the preimage

    // Exercise: create the memo

    // try to create the invoice
    try {
        const paymentRequest = await this.invoiceDataMapper.add(sats, memo, preimage);
        return {
            success: true,
            paymentRequest,
        };
    } catch (ex) {
        return {
            success: false,
            error: ex.message,
        };
    }
}

</code></pre>
<p>When you are finished you can verify you successfully implemented the method with the following command:</p>
<pre><code>npm run test:server -- --grep AppController.*createInvoice
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h1>
<p>We have now completed all of the application's core logic. The only code that we have not discussed is the glue that holds it all together. As with our previous application, this one is bootstrapped inside of <code>server/Server.ts</code>. We're going to skip going into the heavy details of this class but you should take a look to see how things are wired up.</p>
<p>If you take take a look at <code>server/Server.ts</code> you can see that we construct an instance of <code>AppController</code> and call the <code>start</code> method.</p>
<pre><code class="language-typescript">// start the application logic
await appController.start(
  &quot;0000000000000000000000000000000000000000000000000000000000000001&quot;,
  1000
);
</code></pre>
<p>You can see that we start our application with the <code>seed</code> value of <code>0000000000000000000000000000000000000000000000000000000000000001</code>. You can start your application with any seed value and it will restart the game using that new seed.</p>
<p>The remainder of this file constructs the Express webserver and starts the WebSocket server. As with our previous application, a React application uses REST calls and WebSockets to communicate with our application code.</p>
<p>You may also notice that we hook into the <code>AppController</code> to listen for changes to links. As we talked about in the previous section, our <code>AppController</code> implements an observer pattern. Inside <code>Server.ts</code> we make the WebSocket server an observer of link changes that are emitted by the <code>AppController</code>.</p>
<pre><code class="language-typescript">// broadcast updates to the client
appController.listener = (links: Link[]) =&gt;
  socketServer.broadcast(&quot;links&quot;, links);
</code></pre>
<p>Lastly we have two API's that Express mounts: <code>server/api/LinkApi</code> and <code>server/api/InvoiceApi</code>. Both of these APIs parse requests and call methods in our <code>AppController</code> to retrieve the list of <code>Link</code> or create a new invoice for a user.</p>
<p>With that, your application is ready to fire up and test!</p>
<h2 id="exercise-run-the-application"><a class="header" href="#exercise-run-the-application">Exercise: Run the Application!</a></h2>
<p>You should be able to run the <code>npm start</code> from the command line to start the application!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="further-exploration-1"><a class="header" href="#further-exploration-1">Further Exploration</a></h1>
<p>I hope you have enjoyed building this application and learned a bit more about building Lightning Applications with invoices. This application is ripe for extending in interesting ways. Astute readers may have already recognized a few issues with this approach already. A few thoughts to leave you with:</p>
<ul>
<li>
<p>What if Bob and Carol both pay invoices to take leadership in a chain? A standard invoice is automatically resolved when payment is received. How could you modify the application to allow conditional payment resolution?</p>
</li>
<li>
<p>This scheme could be extended to perform digital transfer. How might this scheme be modified to so that the current leader is required to participate in the transfer of leadership?</p>
</li>
<li>
<p>The current scheme requires the server to publish its signature of the <code>linkId</code> for an owner to reconstruct the proof. Is there anyway to modify the scheme so that the preimage contains all the information needed for the owner to reconstruct a proof of ownership with only the preimage?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lightning-network-advanced-topics"><a class="header" href="#lightning-network-advanced-topics">Lightning Network Advanced Topics</a></h1>
<p>This section discusses advanced topics of the Lightning Network and currently includes:</p>
<ul>
<li><a href="advanced/./hold_invoices.html">Hold Invoice</a></li>
<li><a href="advanced/./spontanenous_keysend.html">Spontaneous payments with Keysend</a></li>
<li><a href="advanced/./circular_rebalancing.html">Circular rebalancing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-setup-2"><a class="header" href="#environment-setup-2">Environment Setup</a></h1>
<p>The application code is available in the <a href="https://github.com/bmancini55/building-lightning-advanced">Building on Lightning: Advanced</a> on GitHub. To get started, you can clone this repository:</p>
<pre><code>git clone https://github.com/bmancini55/building-lightning-advanced.git
</code></pre>
<p>Navigate to the repository:</p>
<pre><code>cd building-lightning-advanced
</code></pre>
<p>The repository uses <code>npm</code> scripts to perform common tasks. To install the dependencies, run:</p>
<pre><code>npm install
</code></pre>
<p>Each section has scripts inside of the <code>exercises</code> directory.</p>
<p>We'll also need a Lightning Network environment to test. You can create a new Polar environment or reuse an existing one. Some of these exercises will require specific configurations of nodes and channels, so feel free to destroy and recreate environments as needed.</p>
<h2 id="exercise-configuring-env-to-connect-to-lnd-2"><a class="header" href="#exercise-configuring-env-to-connect-to-lnd-2">Exercise: Configuring <code>.env</code> to Connect to LND</a></h2>
<p>We'll again use the <code>dotenv</code> package to simplify environment variables.</p>
<p>You'll need to add some values to the <code>.env</code> inside the repository root. Specifically we'll set values for the following:</p>
<ul>
<li><code>LND_RPC_HOST</code> is the host for LND RPC</li>
<li><code>LND_ADMIN_MACAROON_PATH</code> is the file path to the admin Macaroon</li>
<li><code>LND_CERT_PATH</code> is the certificate we use to securely connect with LND</li>
</ul>
<p>To populate these values navigate to Polar. To access Alice's node by clicking on Alice and then click on the <code>Connect</code> tab. You will be shown the information on how to connect to the GRPC and REST interfaces. Additionally you will be given paths to the network certificates and macaroon files that we will need in <code>.env</code>.</p>
<p><img src="advanced/../images/ch1_polar_connect_to_alice.png" alt="Connect to Alice" /></p>
<p>Go ahead and add the three environment variables defined above to <code>.env</code>.</p>
<pre><code># LND configuration
LND_RPC_HOST=
LND_ADMIN_MACAROON_PATH=
LND_CERT_PATH=
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hold-invoices"><a class="header" href="#hold-invoices">Hold Invoices</a></h1>
<p>Hold invoices (sometimes referred to as hodl invoices) are a mechanism for delaying the settlement of an invoice. Typically upon receipt of a payment, the recipient releases the preimage to settle the incoming HTLC. With hold invoices, the release of the preimage is not automatic.</p>
<p>Let's consider a scenario with a typical invoice. Bob is paying Alice for a book. Alice creates the invoice for the book and provides it to Bob. Bob pays the invoice and it is immediately settled when Alice's node receives payment. Alice now has the funds. Alice goes and looks for the book, but alas she is sold out. She needs to refund Bob his money. Alice has to ask Bob to create an invoice so she can refund his money then make a payment to him.</p>
<p>This is obviously cumbersome. Additionally, Alice and Bob are likely to lose out on routing fees along the way.</p>
<p>With a hold invoice, after payment is received, the merchant can validate some condition and then settle the transaction. With our example above, Alice delays settlement after she receives Bob's payment. She can verify that she has the book. If she does have the book she settles the transaction. If she doesn't have the book she can cancel the invoice and Bob is immediately returned his funds as if the payment failed.</p>
<p>This brings up two points:</p>
<ol>
<li>Hold invoices look just like normal invoices to Bob, so if Alice cancels his payment, she must notify him that it was cancelled.</li>
<li>Hold invoices tie up funds along the route. This behavior is similar to an actual attack vector on Lightning known as a griefing attack. So if you use hold invoices, it is best to settle them as soon as possible.</li>
</ol>
<p>Beyond refunds, hold invoices have a few other uses:</p>
<ul>
<li><strong>Fidelity bonds</strong> - you can think of this as a deposit on good behavior. A payment can be made to a service provider to access the service. If the user is not malicious the invoice can be cancelled. If the user misbehavior, the invoice can be settled and the funds in the bond taken by the service provider.</li>
<li><strong>Atomic delivery</strong> - the buyer of some good generates a preimage. The buyer pays the invoice and the merchant has payment. The merchant can send the good. Upon delivery a courier/third party collects and verifies the preimage and provides it to the merchant who can now access the funds.</li>
<li><strong>Swaps</strong> - Alice wants to move funds from a channel to her on-chain wallet. She creates a preimage and provides the hash to Bob. Bob runs a swap service and constructs a hold invoice using the hash. When he receives payment from Alice he will pay an HTLC on-chain that can be resolved via the preimage. Once Alice sees this HTLC, she can claim the funds with the preimage. Alice now has the funds on-chain and Bob is able to settle the hold invoice.</li>
</ul>
<p>These examples highlight an interesting aspect of the hold invoice: the preimage of an invoice can be unknown to the invoice creator.</p>
<p>Now that you have a good understanding of hold invoices, we'll do a few exercises to use them via code.</p>
<h2 id="exercise-creating-a-hold-invoice"><a class="header" href="#exercise-creating-a-hold-invoice">Exercise: Creating a Hold Invoice</a></h2>
<p>The first exercise is creating a hold invoice using a script. We'll start by using the command line script at <code>/exercises/hold-invoices/Hash.ts</code> to create a preimage and its hash from some arbitrary data.</p>
<pre><code>npm start &quot;exercises/hold-invoices/Hash.ts&quot; -- &quot;example 1&quot;
</code></pre>
<p>Dev note: Because we are using an <code>npm</code> script to start our file, we need to differentiate between arguments that are provided to the <code>npm</code> command and those that we want to pass to the script. This is done with <code>--</code>. As you can see, the first argument that is provided to the script is <code>&quot;example 1&quot;</code>.</p>
<p>Running this script will output the raw data, the 32-byte preimage for this data, and the
hash of the preimage.</p>
<pre><code>data:      example 1
preimage:  8ee89711330c1ccf39a2e65ad12bbd7df4a4a2ee857f53b4823f00fecb7bd252
hash:      964e1161e2b41cb66982453a4b7b154750e26b04c63116f9ef8e3b1adb30e71a
</code></pre>
<p>Take a look at the code in <code>Hash.ts</code></p>
<pre><code class="language-typescript">// /exercises/hold-invoices/Hash.ts
async function run() {
  // read the command line argument, first value starts at index 2.
  const data = process.argv[2];

  // hash the raw data to make it 32-bytes
  const preimage = sha256(data);

  // hash the preimage value
  const hash = sha256(preimage);

  console.log(&quot;data:     &quot;, data);
  console.log(&quot;preimage: &quot;, preimage.toString(&quot;hex&quot;));
  console.log(&quot;hash:     &quot;, hash.toString(&quot;hex&quot;));
}
</code></pre>
<p>This script accepts any value on the command line. This value will be used to generate the preimage. Lightning Network preimages must be 32-bytes, so we use the SHA256 hash function to turn the arbitrary length value into 32-bytes.</p>
<p>Once we have the 32-byte preimage we can convert it into the hash used in the invoice. As we previously discussed, in order to create a hold invoice only requires knowledge of the hash, so in this example we could have received a hash from a third party and it would be ok that we have no knowledge of the actual preimage.</p>
<p>Next we'll use the create script to build our invoice by passing in the hash value.</p>
<pre><code>npm start &quot;exercises/hold-invoices/Create.ts&quot; -- 964e1161e2b41cb66982453a4b7b154750e26b04c63116f9ef8e3b1adb30e71a
</code></pre>
<p>This will return a result with the payment request information as if it was a normal invoice.</p>
<pre><code>{
  payment_request: 'lnbcrt10u1p3wzutmpp5je8pzc0zkswtv6vzg5ayk7c4gagwy6cyccc3d7003ca34kesuudqdqdg4ux2unrd9ek2cqzpgsp5z3qeuh5eq6dfuyemgkkk95y0r2cfek6s08cvaze0q6w28dphxmys9qyyssqgxxde9netfts3g8gkqv2hmaj8fety2vjjp67utn8vnp8u6uw6cr33c0g4fnjw029m68rmn2lumwnxgs4rvp0tj47lrkuptcwu7dz2xcp2jx3a2',
  add_index: '0',
  payment_addr: &lt;Buffer &gt;
}
</code></pre>
<p>Take a look at the <code>run</code> function in <code>/exercises/hold-invoices/Create.ts</code> to see how to use the <code>AddHoldInvoice</code> API of LND.</p>
<pre><code class="language-typescript">async function run(): Promise&lt;Lnd.AddHoldInvoiceResult&gt; {
  // Expects the hash as 32-byte hex
  const hash = Buffer.from(process.argv[2], &quot;hex&quot;);

  // Constructs a LND client from the environment variables
  const client = await ClientFactory.lndFromEnv();

  // Finally construct the HOLD invoice
  const options: Lnd.AddHoldInvoiceInput = {
    memo: &quot;Exercise&quot;,
    value: &quot;1000&quot;,
    hash,
  };
  return await client.addHoldInvoice(options);
}
</code></pre>
<p>This invoice can then be provided to Bob so that he can pay it.</p>
<p><img src="advanced/../images/ch3_pay_hold_invoice.png" alt="Pay Hold Invoice" /></p>
<p>Instead of completing, you'll see that the payment looks &quot;stuck&quot;. That's because the payment hasn't settled yet. Alice will either need to settle or cancel the invoice.</p>
<h2 id="exercise-cancelling-the-hold-invoice"><a class="header" href="#exercise-cancelling-the-hold-invoice">Exercise: Cancelling the Hold Invoice</a></h2>
<p>Next we'll see what happens if Alice wants to cancel the invoice.</p>
<p>We use the <code>Cancel</code> script using the hash value that we generated.</p>
<pre><code>npm start &quot;exercises/hold-invoices/Cancel.ts&quot; -- 964e1161e2b41cb66982453a4b7b154750e26b04c63116f9ef8e3b1adb30e71a
</code></pre>
<p>We should also see that the payment in polar has failed.</p>
<p>Take a look at the <code>/exercises/hold-invoices/Cancel.ts</code> script to see how we call the <code>CancelInvoice</code> API of LND.</p>
<pre><code class="language-typescript">async function run(): Promise&lt;void&gt; {
  // Expects the hash as a 32-byte hex encoded argument
  const hash = Buffer.from(process.argv[2], &quot;hex&quot;);

  // Constructs a LND client from the environment variables
  const client = await ClientFactory.lndFromEnv();

  // Finally we can cancel the invoice.
  return await client.cancelInvoice(hash);
}
</code></pre>
<h2 id="exercise-settling-an-invoice"><a class="header" href="#exercise-settling-an-invoice">Exercise: Settling an Invoice</a></h2>
<p>Alice cancelled the last invoice that was generated. This time we'll try settling an invoice. To do this we need to generate a new hold invoice. We start by creating a new hash/preimage pair.</p>
<pre><code>npm start &quot;exercises/hold-invoices/Hash.ts&quot; -- &quot;example settle&quot;
</code></pre>
<p>This will result in output that looks like:</p>
<pre><code>data:      example settle
preimage:  64b64bad988b06b70973f995c80acc132ec22044984d57d799a6d09a31bec3e1
hash:      33f35509e040e0cc653691caa22f99e4d7fcaf714f2bcdda13ce369ca844f979
</code></pre>
<p>With the new preimage we can create a new invoice using the <code>Create</code> script.</p>
<pre><code> npm start &quot;exercises/hold-invoices/Create.ts&quot; -- 33f35509e040e0cc653691caa22f99e4d7fcaf714f2bcdda13ce369ca844f979
</code></pre>
<p>This will generate a new payment request that Bob can try to pay again.</p>
<p><img src="advanced/../images/ch3_pay_hold_invoice2.png" alt="Pay Second Invoice" /></p>
<p>Instead of cancelling, this time Alice is going to settle the invoice.</p>
<p>She can settle it using the <code>Settle</code> script and providing the preimage <code>64b64bad988b06b70973f995c80acc132ec22044984d57d799a6d09a31bec3e1</code>.</p>
<pre><code>npm start &quot;exercises/hold-invoices/Settle.ts&quot; -- 64b64bad988b06b70973f995c80acc132ec22044984d57d799a6d09a31bec3e1
</code></pre>
<p>This time, Bob should see the invoice successfully paid!</p>
<p>You can check out the <code>Settle</code> script that shows how to use the <code>SettleInvoice</code> API of LND.</p>
<pre><code class="language-typescript">async function run(): Promise&lt;void&gt; {
  // Expects the preimage in the command line is a 32-byte hex encoded value
  const preimage = Buffer.from(process.argv[2], &quot;hex&quot;);

  // Constructs a LND client from the environment variables
  const client = await ClientFactory.lndFromEnv();

  // Settle the invoice using the 32-byte preimage
  return await client.settleInvoice(preimage);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spontaneous-payments-with-keysend"><a class="header" href="#spontaneous-payments-with-keysend">Spontaneous Payments with Keysend</a></h1>
<p>Spontaneous payments are a type of payment that doesn't require the recipient to generate an invoice. This type of payment is initiated by the sender and the recipient may or may not be expecting the payment.</p>
<p>Spontaneous payments are useful for a variety of scenarios:</p>
<ul>
<li>Partial refunds - a merchant can issue a refund for an item they are unable to fulfill.</li>
<li>Tipping - a spontaneous payment can be be made to give someone some balance</li>
</ul>
<p>The major downside to spontaneous payments is that you lose proof of payment for a specific invoice since the preimage is generated by the payment sender.</p>
<h1 id="keysend"><a class="header" href="#keysend">Keysend</a></h1>
<p>Keysend is defined in <a href="https://github.com/lightning/blips/blob/master/blip-0003.md">BLIP 0003</a>. It is an optional feature of Lightning Network nodes that enables spontaneous payments.</p>
<p>This feature relies on upon <a href="https://github.com/lightning/bolts/blob/bc86304b4b0af5fd5ce9d24f74e2ebbceb7e2730/04-onion-routing.md#tlv_payload-format">variable length onion packets</a>. It works by encoding the preimage into onion data that is decrypted by the payment recipient in the last hop of the onion. Due to the onion construction this preimage is not visible to the intermediary hops until the payment is settled by the final node.</p>
<p>In order to make a keysend payment requires:</p>
<ul>
<li>generating a unique 32-byte preimage</li>
<li>create a sha256 hash of the preimage</li>
<li>set a custom onion record with identifier 5482373484 to the preimage value</li>
<li>sending a payment using the hash of the preimage</li>
</ul>
<p>A receiving node that has keysend enabled will understand the custom onion record. It will then create an invoice on the fly and resolve it using the preimage supplied by the sender.</p>
<h2 id="keysend-on-c-lightning"><a class="header" href="#keysend-on-c-lightning">Keysend on C-Lightning</a></h2>
<p>Keysend is enabled by default on C-Lightning. Keysend payments can be sent using the <a href="https://lightning.readthedocs.io/lightning-keysend.7.html"><code>keysend</code> CLI command</a></p>
<p>For example if Carol is running a C-Lightning node and wants to send payment 50,000 satoshis to Bob who has a node identifier of 0227bfa020ce5765ef852555c5fbb58bdb3edbeb44f51b2eeb5e7167e678a2771e. She would use the command</p>
<pre><code>lightning-cli keysend 0227bfa020ce5765ef852555c5fbb58bdb3edbeb44f51b2eeb5e7167e678a2771e 50000000
</code></pre>
<p><img src="advanced/../images/ch3_keysend_clightning.png" alt="C-Lightning Keysend" /></p>
<h2 id="keysend-on-lnd"><a class="header" href="#keysend-on-lnd">Keysend on LND</a></h2>
<p>Keysend is an optional feature on LND. To enable this feature requires starting your LND using the <code>--accept-keysend</code> flag.</p>
<p>You can do this in Polar by right-clicking an LND node and selecting <code>Advanced Options</code>. Under advanced options, click the &quot;Pre-fill with the default command&quot; button, then add the <code>--accept-keysend</code> flag.</p>
<p><img src="advanced/../images/ch3_keysend_enable_lnd.png" alt="Enable Keysend on LND" /></p>
<p>Restart your node.</p>
<p>You can then open a terminal and send payments using the <code>sendpayment</code> CLI command by providing a destination <code>--dest=&lt;node_id&gt;</code>, amount in satoshis <code>--amt=&lt;value&gt;</code> and the flag <code>--keysend</code></p>
<p>For example to send 10,000 satoshi's to Carol's node that has the node identifier 0396e97fb9a10aaf7f1ccbe1fd71683863b9d279b3190f7561ceacd44d3e7a0791:</p>
<pre><code>lncli sendpayment --dest=0396e97fb9a10aaf7f1ccbe1fd71683863b9d279b3190f7561ceacd44d3e7a0791 --amt=10000 --keysend
</code></pre>
<p><img src="advanced/../images/ch3_keysend_lnd.png" alt="LND Keysend" /></p>
<h2 id="exercise-try-keysend-from-code"><a class="header" href="#exercise-try-keysend-from-code">Exercise: Try Keysend from Code</a></h2>
<p>Now we can try performing a keysend from code. Using your LND node that has keysend enabled you can run the script and supply the destination node identifier and the amount in satoshis. This script relies on the <a href="https://api.lightning.community/#sendpaymentv2"><code>SendPaymentV2</code></a> API of LND and supplies the custom onion record with the payment preimage.</p>
<pre><code>npm run start exercises/spontaneous-keysend/Run.ts &lt;dest_node_id&gt; &lt;amt&gt;
</code></pre>
<p>The script will run the following code located in <code>exercises/spontaneous-keysend/Run.ts</code>.</p>
<pre><code class="language-typescript">async function run(): Promise&lt;void&gt; {
  // Obtains destination and amount from command line
  const dest = Buffer.from(process.argv[2], &quot;hex&quot;);
  const amt = process.argv[3];

  // Generates a preimage and a hash
  const secret = crypto.randomBytes(32);
  const hash = sha256(secret);

  console.log(&quot;Dest    &quot;, dest.toString(&quot;hex&quot;));
  console.log(&quot;Amt     &quot;, amt);
  console.log(&quot;Preimage&quot;, secret.toString(&quot;hex&quot;));
  console.log(&quot;Hash    &quot;, hash.toString(&quot;hex&quot;));

  // Constructs a LND client from the environment variables
  const client = await ClientFactory.lndFromEnv();

  // Initiate spontaneous using keysend
  await client.sendPaymentV2(
    {
      dest,
      amt,
      payment_hash: hash,
      dest_custom_records: { 5482373484: secret },
      timeout_seconds: 60,
    },
    (payment: Lnd.Payment) =&gt; {
      console.log(util.inspect(payment, false, 6, true));
    }
  );
}
</code></pre>
<p>This script will do the following:</p>
<ul>
<li>Read the destination and amount from the command line</li>
<li>Create a random 32-byte preimage</li>
<li>Create a sha256 hash of the preimage</li>
<li>Construct an LND client from our environment variables as we've done before</li>
<li>Use the payment using <code>sendPaymentv2</code> and enabling keysend by including a custom onion record type=5482373484 and the value being the preimage.</li>
</ul>
<p>When it completes successfully you should see a payment status with the <code>status=SUCCEEDED</code> output to the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circular-rebalancing-in-the-lightning-network"><a class="header" href="#circular-rebalancing-in-the-lightning-network">Circular Rebalancing in the Lightning Network</a></h1>
<p>Each Lighting Network channels has a total capacity. This total capacity is split between the two nodes in the channel. When a channel is initially opened (unless some amount is initially pushed to the remote node), the channel balance is 100% on one side of the person that created the channel. With this unbalance, a payment can only be sent. There is no inbound capacity. If you tried to receive a payment, it would fail.</p>
<p>Similarly, a channel that is opened to you will only have capacity on the remote side. Initially you can receive payments from that channel, but you will be unable send payments using that channel.</p>
<p>As you send and receive payments, the balances of your channels will shift. Ideally, you would want to maintain some split of inbound versus outbound capacity.</p>
<p>You can control this balance by performing circular rebalancing.</p>
<h2 id="circular-rebalancing"><a class="header" href="#circular-rebalancing">Circular Rebalancing</a></h2>
<p>Circular Rebalancing is a technique for when you have multiple channels open and want to change the inbound/outbound ratio for your channels. The general idea is that you pay yourself (only losing some fees along the way) using a channel that has excess outbound capacity and you accept payment through the channel that has excess inbound capacity. In this regard, the payment generates a circle and the net result is that your channel balances are more evenly distributed for both sending and receiving.</p>
<p>Create a Polar environment with three nodes: Alice, Bob, and Carol where:</p>
<ul>
<li>Alice opens a channel to Bob</li>
<li>Bob opens a channel to Carol</li>
<li>Carol opens a channel to Alice</li>
</ul>
<p><img src="advanced/../images/ch3_circular_rebalancing_env.png" alt="Circular Rebalancing Environment" /></p>
<p>In this environment, Alice has full outbound capacity one channel, and full inbound capacity on a second channel.</p>
<p>With this environment setup, lets see if we can perform a circular rebalance.</p>
<h2 id="exercise-rebalance-capacity-script"><a class="header" href="#exercise-rebalance-capacity-script">Exercise: Rebalance Capacity Script</a></h2>
<p>This script is located in <code>./execises/rebalancing/Run.ts</code>. This script does a few things:</p>
<ol>
<li>constructs an LND client using the envrionment variables</li>
<li>accepts an amount in satoshis from the command line</li>
<li>accepts a comma separated list of node identifiers for how payments should be routed</li>
<li>obtains the starting balance of channels</li>
<li>creates an invoice for the amount specified</li>
<li>creates a circular route</li>
<li>sends the payment along that route</li>
<li>obtains the ending balance of channels</li>
</ol>
<p>The first two items are obvious so we'll skip them for now.</p>
<h3 id="node-identifiers"><a class="header" href="#node-identifiers">Node Identifiers</a></h3>
<p>Next we need to split up a list of node public keys and convert strings into Buffers. The code for this is straightforward but the intent is a bit more confusing.</p>
<pre><code>// Read the hop pubkeys as hex strings and convert them to buffers
const hop_pubkeys = process.argv[3].split(&quot;,&quot;).map(v =&gt; Buffer.from(v, &quot;hex&quot;));
</code></pre>
<p>What we want is a list of node identifiers such that we start with the node we are sending to and end with our node. For example if we had outbound capacity from <code>Alice -&gt; Bob</code> and inbound capacity from <code>Carol -&gt; Alice</code> we want to send the payment using the <code>Alice -&gt; Bob</code> channel, through the <code>Bob -&gt; Carol</code> channel, then finally back to ourselves with the <code>Carol -&gt; Alice</code> channel.</p>
<p>Our list of node identifiers would then correspond to those hops in the route: <code>pubkey(Bob),pubkey(Carol),pubkey(Alice)</code> or more concretely:</p>
<pre><code>Alice=02a3cc61dd74a22f575b22f4ece6400f5754db9fab8a72a53b2a789ceca34a9d7e
Bob  =0227bfa020ce5765ef852555c5fbb58bdb3edbeb44f51b2eeb5e7167e678a2771e
Carol=0396e97fb9a10aaf7f1ccbe1fd71683863b9d279b3190f7561ceacd44d3e7a0791

0227bfa020ce5765ef852555c5fbb58bdb3edbeb44f51b2eeb5e7167e678a2771e,0396e97fb9a10aaf7f1ccbe1fd71683863b9d279b3190f7561ceacd44d3e7a0791,02a3cc61dd74a22f575b22f4ece6400f5754db9fab8a72a53b2a789ceca34a9d7e
</code></pre>
<p>You'll notice that the final node_id is always our node.</p>
<h3 id="creating-the-invoice"><a class="header" href="#creating-the-invoice">Creating the Invoice</a></h3>
<p>You'll notice in the steps that we create an invoice for the specified amount in satoshis.</p>
<pre><code class="language-typescript">const invoice = await client.addInvoice({ amt });
</code></pre>
<p>This step is nothing special. In theory we could use keysend or another form of spontaneous payment instead generating the invoice ahead of time, but this allows us to create a custom memo if we wanted to do so.</p>
<h3 id="creating-the-route"><a class="header" href="#creating-the-route">Creating the Route</a></h3>
<p>Next you'll see that we need to construct a route from our list of nodes. We do this using the <a href="https://api.lightning.community/#buildroute"><code>BuildRoute</code></a> API. This API accepts a list of node pubkeys that we conveniently just created. This API uses LNDs router to help us a build a path that is likely to succeed.</p>
<pre><code class="language-typescript">// Build a route using the hop_pubkeys
const { route } = await client.buildRoute({
  final_cltv_delta: 40,
  hop_pubkeys,
  amt_msat,
});
</code></pre>
<p>The result of this call is a route that includes a series of hops that traverse channels through each of the specified nodes.</p>
<p>We need to do one not obvious thing to make the payment successful. We need to modify the last hop to include a payment secret. This <code>payment_secret</code> was initially added to prevent probing attacks and it is now used to enable <a href="https://github.com/lightning/bolts/commit/4c3d01616d8e7c1c39212f97562964eceb769c08">multipath payments</a>. LND does not currently (as of v0.12.1-beta) have this baked into the <code>BuildRoute</code> API so we'll need to add this data manually to the <code>mpp_record</code> of our last hop:</p>
<pre><code>route.hops[route.hops.length - 1].mpp_record = {
    payment_addr: invoice.payment_addr,
    total_amt_msat: amt_msat,
};
</code></pre>
<p>After that is done, we should have a route that is constructed that looks similar to this below. You can see that it has three hops: the first goes from <code>Alice -&gt; Bob</code>, the second from <code>Bob -&gt; Carol</code>, and the final goes from <code>Carol -&gt; Alice</code> and includes the <code>payment_secret</code> value that will be included in the Onion TLV of the last hop.</p>
<pre><code class="language-json">{
  hops: [
    {
      custom_records: {},
      chan_id: '192414534926337',
      chan_capacity: '250000',
      amt_to_forward: '50001',
      fee: '0',
      expiry: 260,
      amt_to_forward_msat: '50001050',
      fee_msat: '501',
      pub_key: '0396e97fb9a10aaf7f1ccbe1fd71683863b9d279b3190f7561ceacd44d3e7a0791',
      tlv_payload: true,
      mpp_record: null
    },
    {
      custom_records: {},
      chan_id: '185817465159681',
      chan_capacity: '250000',
      amt_to_forward: '50000',
      fee: '1',
      expiry: 220,
      amt_to_forward_msat: '50000000',
      fee_msat: '1050',
      pub_key: '0227bfa020ce5765ef852555c5fbb58bdb3edbeb44f51b2eeb5e7167e678a2771e',
      tlv_payload: true,
      mpp_record: null
    },
    {
      custom_records: {},
      chan_id: '118747255865345',
      chan_capacity: '250000',
      amt_to_forward: '50000',
      fee: '0',
      expiry: 220,
      amt_to_forward_msat: '50000000',
      fee_msat: '0',
      pub_key: '02a3cc61dd74a22f575b22f4ece6400f5754db9fab8a72a53b2a789ceca34a9d7e',
      tlv_payload: true,
      mpp_record: {
        payment_addr: &lt;Buffer e8 68 fb fa e2 b4 91 0e 0a a3 9d 9a 52 e2 04 0a ef 45 ad a6 5e 9c ff 54 a9 d1 fd 6d 80 bd 4b e0&gt;,
        total_amt_msat: '50000000'
      }
    }
  ],
  total_time_lock: 266,
  total_fees: '1',
  total_amt: '50001',
  total_fees_msat: '1551',
  total_amt_msat: '50001551'
}
</code></pre>
<p>Believe it or not, we just did it the easy way. If you have multiple channels open with a peer, it is likely that you would want to manually construct your first and last hops to ensure your route pays along the preferred path.</p>
<h3 id="sending-payment-to-the-route"><a class="header" href="#sending-payment-to-the-route">Sending Payment to the Route</a></h3>
<p>The last fun piece of coding is sending the payment along the route using the <a href="https://api.lightning.community/#sendtoroutev2"><code>SendToRouteV2</code></a> option. This method sends a payment for the hash along the route.</p>
<pre><code class="language-typescript">const result = await client.sendToRouteV2(invoice.r_hash, route, false);
</code></pre>
<p>It will return a status of <code>SUCCEEDED</code> and the route that was used for payment if it was successful.</p>
<pre><code class="language-json">{
  status: 'SUCCEEDED',
  route: {
    hops: [
      {
        custom_records: {},
        chan_id: '192414534926337',
        chan_capacity: '250000',
        amt_to_forward: '50001',
        fee: '0',
        expiry: 260,
        amt_to_forward_msat: '50001050',
        fee_msat: '501',
        pub_key: '0396e97fb9a10aaf7f1ccbe1fd71683863b9d279b3190f7561ceacd44d3e7a0791',
        tlv_payload: true,
        mpp_record: null
      },
      {
        custom_records: {},
        chan_id: '185817465159681',
        chan_capacity: '250000',
        amt_to_forward: '50000',
        fee: '1',
        expiry: 220,
        amt_to_forward_msat: '50000000',
        fee_msat: '1050',
        pub_key: '0227bfa020ce5765ef852555c5fbb58bdb3edbeb44f51b2eeb5e7167e678a2771e',
        tlv_payload: true,
        mpp_record: null
      },
      {
        custom_records: {},
        chan_id: '118747255865345',
        chan_capacity: '250000',
        amt_to_forward: '50000',
        fee: '0',
        expiry: 220,
        amt_to_forward_msat: '50000000',
        fee_msat: '0',
        pub_key: '02a3cc61dd74a22f575b22f4ece6400f5754db9fab8a72a53b2a789ceca34a9d7e',
        tlv_payload: true,
        mpp_record: {
          total_amt_msat: '50000000',
          payment_addr: &lt;Buffer e8 68 fb fa e2 b4 91 0e 0a a3 9d 9a 52 e2 04 0a ef 45 ad a6 5e 9c ff 54 a9 d1 fd 6d 80 bd 4b e0&gt;
        }
      }
    ],
    total_time_lock: 266,
    total_fees: '1',
    total_amt: '50001',
    total_fees_msat: '1551',
    total_amt_msat: '50001551'
  },
  attempt_time_ns: '1660757083463543000',
  resolve_time_ns: '1660757084439054000',
  failure: null,
  preimage: &lt;Buffer a9 92 ad 78 42 04 f4 97 ca 96 99 8c 6f 01 67 7f 31 b6 50 38 0c 8a bb 4d 87 1b ec 9d 71 5c 5c 4e&gt;,
  attempt_id: '2080'
}
</code></pre>
<h3 id="complete-view"><a class="header" href="#complete-view">Complete View</a></h3>
<p>You can view the complete code below:</p>
<pre><code class="language-typescript">async function run(): Promise&lt;void&gt; {
  // Constructs a LND client from the environment variables
  const client = await ClientFactory.lndFromEnv();

  // Read the amount from the command line
  const amt = Number(process.argv[2]);

  // Read the hop pubkeys as hex strings and convert them to buffers
  const hop_pubkeys = process.argv[3].split(&quot;,&quot;).map(hexToBuf);

  // Convert the amount to millisatoshi
  const amt_msat = (amt * 1000).toString();

  // Load channels before
  const startChannels = await client.listChannels();

  // Construct a new invoice for the amount
  const invoice = await client.addInvoice({ amt });
  console.log(util.inspect(invoice, false, 10, true));

  // Build a route using the hop_pubkeys
  const { route } = await client.buildRoute({
    final_cltv_delta: 40,
    hop_pubkeys,
    amt_msat,
  });

  // Modify the last hop to include the payment_secret and total_amt_msat values
  route.hops[route.hops.length - 1].mpp_record = {
    payment_addr: invoice.payment_addr,
    total_amt_msat: amt_msat,
  };
  console.log(util.inspect(route, false, 10, true));

  // Send the payment for our invoice along our route
  const result = await client.sendToRouteV2(invoice.r_hash, route, false);
  console.log(util.inspect(result, false, 10, true));

  // Give channel balances time to settle
  await wait(1000);

  // Capture end channels
  const endChannels = await client.listChannels();

  // Output balance changes
  for (const start of startChannels.channels) {
    const end = endChannels.channels.find((e) =&gt; e.chan_id === start.chan_id);
    console.log(
      &quot;channel&quot;,
      start.initiator ? &quot;outgoing&quot; : &quot;incoming&quot;,
      start.chan_id,
      &quot;start_balance&quot;,
      start.local_balance,
      &quot;end_balance&quot;,
      end?.local_balance
    );
  }
}
</code></pre>
<h3 id="running-the-script"><a class="header" href="#running-the-script">Running the Script</a></h3>
<p>To run the script:</p>
<ol>
<li>Gather the node_ids for Bob,Carol,Alice</li>
<li>Use <code>npm start exercises/reblancing/Run.ts &lt;satashis&gt; &lt;comma_separated_list_of_nodes&gt;</code></li>
</ol>
<p>For example:</p>
<pre><code>npm start exercises/rebalancing/Run.ts 10000 \
0227bfa020ce5765ef852555c5fbb58bdb3edbeb44f51b2eeb5e7167e678a2771e,0396e97fb9a10aaf7f1ccbe1fd71683863b9d279b3190f7561ceacd44d3e7a0791,02a3cc61dd74a22f575b22f4ece6400f5754db9fab8a72a53b2a789ceca34a9d7e
</code></pre>
<h2 id="afterthoughts"><a class="header" href="#afterthoughts">Afterthoughts</a></h2>
<p>Rebalancing is a complicated but necessary action for many node operators. Many tools already exist to help you:</p>
<p><strong>LND</strong>:</p>
<ul>
<li><a href="https://github.com/C-Otto/rebalance-lnd">Rebalance LND</a></li>
<li><a href="https://github.com/alexbosworth/balanceofsatoshis">Balance of Satoshis</a></li>
</ul>
<p><strong>C-Lightning</strong>:</p>
<ul>
<li><a href="https://github.com/lightningd/plugins/tree/master/rebalance">Rebalance Plugin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-loop-out-service-for-the-lightning-network"><a class="header" href="#building-a-loop-out-service-for-the-lightning-network">Building a Loop-Out Service for the Lightning Network</a></h1>
<p>In this section we'll discuss loop-out of funds from a Lightning Network channel using <a href="advanced/./hold_invoices.html">hold invoices</a>. A loop-out is the ability to move funds from an off-chain Lightning Network channel to an off-chain address in a trustless way.</p>
<p>An obvious use case for this is a merchant that a receives a large inflow of payments. At a certain point the merchant channel's inbound capacity will be exhausted and the merchant will have a large amount of outbound capacity. A loop-out allows the merchant to simultaneously change the balance of their channel so that they once again have inbound capacity and move the funds to an on-chain address for safe keeping!</p>
<p>This article is going to show how to build a simple loop-out service. There are a lot of moving pieces and we need to have on-chain wallet capabilities. In order to keep this article somewhat brief we'll forgo building a fully complete and secure loop-out service and instead work through the mechanics. The full working code can be found <a href="https://github.com/bmancini55/building-lightning-advanced/tree/main/exercises/loop-out">here</a>.</p>
<h2 id="mechanics-of-loop-out"><a class="header" href="#mechanics-of-loop-out">Mechanics of Loop-Out</a></h2>
<p>Each loop-out will generate at least two on-chain transaction: one on-chain HTLC and one claim transaction to resolve the HTLC. Performing a loop-out require a service that bridges off-chain Lightning Network payments to on-chain transaction. Functionally the service will broadcast an on-chain HTLC that can be claimed with the hash preimage by the person requesting the loop-out.</p>
<p>So here are the steps for a loop-out between Alice and Bob. Bob runs a loop-out service and Alice wants to migrate some funds on-chain.</p>
<ol>
<li>Alice generates a hash preimage that only she knows and provides the hash, a payment address, and the amount to Bob</li>
<li>Bob generates a hold invoice and provides the payment request and his refund address to Alice</li>
<li>Alice pays the invoice using her Lightning Network node</li>
<li>Bob gets receipt of the payment,</li>
<li>Bob broadcasts an on-chain HTLC that pays Alice if she provides the preimage or it pays him after some timeout period</li>
<li>Alice settles the on-chain HTLC by spending it using the preimage (Alice now has her funds on-chain)</li>
<li>Bob extracts the preimage from the Alice's settlement transaction on-chain</li>
<li>Bob settles the inbound hold invoice (Bob now has funds in his LN channel)</li>
</ol>
<p><img src="advanced/../images/loop_out_sequence.jpg" alt="Loop-Out Sequence" /></p>
<p>Astute readers will recognize that the on-chain HTLC aspect is remarkably similar to how Lightning Network channels make claims against HTLCs when a channel goes on-chain. In order to settle the HTLC outputs one of two things happens:</p>
<ol>
<li>the offerer of an HTLC has access to reclaim the funds after some timeout period</li>
<li>the recipient of an HTLC can claim the funds using the preimage</li>
</ol>
<p>With looping it's much simpler than inside a channel. In our example, Alice can claim the on-chain HTLC using the preimage that she knows. If she does this, then Bob can extract the preimage and settle the off-chain HTLC so that he doesn't lose funds.</p>
<p>One final note is that just like off-chain payments, to ensure there are no funds lost, the timeouts must be larger for incoming HTLCs than the corresponding outgoing HTLC. This ensures that an outgoing HTLC is always fully resolve before the incoming HTLC can be timed out.</p>
<h2 id="building-a-loop-out-client"><a class="header" href="#building-a-loop-out-client">Building a Loop-Out Client</a></h2>
<p>The first step is going to be building a client for Alice. To make our lives easier this client will connect to the service over HTTP to exchange necessary information.</p>
<p>Once the client has an invoice it will:</p>
<ol>
<li>pay the invoice</li>
<li>watch the blockchain for the HTLC</li>
<li>spend the HTLC using the preimage that it knows</li>
</ol>
<p>The code for our client application can be found in <a href="https://github.com/bmancini55/building-lightning-advanced/blob/main/exercises/loop-out/client/Client.ts"><code>exercises/loop-out/client/Client.ts</code></a>. The start of this file contains a few boilerplate things that must be setup:</p>
<ol>
<li>Connect to our Lightning Network node (we use LND again for this example)</li>
<li>Connect to our <code>bitcoind</code> node</li>
<li>Construct a blockchain monitor that will notify our application when blocks are connected</li>
<li>Construct a wallet for storing our keys</li>
</ol>
<p>After this boilerplate, our application needs to generate the information needed by the loop-out service. In this application we'll use <code>@node-lightning/bitcoin</code> library to perform basic Bitcoin functionality. We'll use our wallet to create a new private key. We'll share this with the service using a P2WPKH address.</p>
<pre><code class="language-typescript">const htlcClaimPrivKey = wallet.createKey();
const htlcClaimPubKey = htlcClaimPrivKey.toPubKey(true);
const htlcClaimAddress = htlcClaimPubKey.toP2wpkhAddress();
logger.info(&quot;generated claim address&quot;, htlcClaimAddress);
</code></pre>
<p><em>Note</em>: Why are we using a P2WPKH address instead of a 33-byte public key directly? We could send a 33-byte compressed pubkey, a 20-byte pubkeyhash, or a Bitcoin address (an encoded pubkeyhash). Since we'll be sharing these values over HTTP JSON addresses provide the least ambiguity as to the meaning of the data.</p>
<p>Net we'll create a random preimage and the hash defined as <code>sha256(preimage)</code>. The hash will be used in the invoice and the HTLC construction.</p>
<pre><code class="language-typescript">const preimage = crypto.randomBytes(32);
logger.info(&quot;generated preimage&quot;, preimage.toString(&quot;hex&quot;));

const hash = sha256(preimage);
logger.info(&quot;generated hash&quot;, hash.toString(&quot;hex&quot;));
</code></pre>
<p>With that information we'll make a simple HTTP request to the service:</p>
<pre><code class="language-typescript">const apiRequest: Api.LoopOutRequest = {
  htlcClaimAddress: htlcClaimAddress,
  hash: hash.toString(&quot;hex&quot;),
  loopOutSats: Number(htlcValue.sats),
};
</code></pre>
<p>When executed will look something like</p>
<pre><code>{
  &quot;htlcClaimAddress&quot;: &quot;bcrt1qsnaz83m800prgcgp2dxvv5f9z2x4f5lasfekj9&quot;,
  &quot;hash&quot;: &quot;c8df085d2d3103e944b62d20fe6c59e117ffec97443f76581434e0ea0af9d7ea&quot;,
  &quot;loopOutSats&quot;: 10000
}
</code></pre>
<p>We make the web request</p>
<pre><code class="language-typescript">const apiResponse: Api.LoopOutResponse = await Http.post&lt;Api.LoopOutResponse&gt;(
  &quot;http://127.0.0.1:1008/api/loop/out&quot;,
  apiRequest
);
</code></pre>
<p>The response will contain a Lightning Network payment request and the refund address owned by the service in case we fail to fulfill the on-chain HTLC in time. We now have everything we need to reconstruct the on-chain HTLC.</p>
<p>A sample response looks like:</p>
<pre><code>{
  &quot;htlcRefundAddress&quot;: &quot;bcrt1qgmv0jaj36y8v0mlepswd799sf9q7tparlgphe2&quot;,
  &quot;paymentRequest&quot;: &quot;lnbcrt110u1p3j8ydrpp5er0sshfdxyp7j39k95s0umzeuytllmyhgslhvkq5xnsw5zhe6l4qdqqcqzpgsp55wn3hnhdn3sp4av8t7x5qfpvy4vsdgpyqg6az7gy7fqfg75j49aq9qyyssqpgsjc2y7wvdh7gvg4kyp8lnsv5hgzr0r3xyw0rfydyue9he40wfxzxnp0rcm2lge5qv8hrhfs7j6ecq9r6djwu8z3vuzpqr306g790qqh5kejs&quot;
}
</code></pre>
<p>We can then use the <a href="https://api.lightning.community/#sendpaymentv2"><code>sendPaymentV2</code></a> method of LND to pay the payment request.</p>
<pre><code class="language-typescript">await lightning.sendPaymentV2(
  { payment_request: apiResponse.paymentRequest, timeout_seconds: 600 },
  (invoice) =&gt; {
    logger.info(&quot;invoice status is now:&quot; + invoice.status);
  }
);
</code></pre>
<p>However! Before we make the payment request we want start watching the blockchain for the HTLC. To watch for the HTLC we need to look for a transaction that has a P2WSH output matching our HTLC. Recall that P2WSH outputs use Script that is <code>0x00+sha256(script)</code>. Only when the output is spent is the script revealed as part of the witness. So for our purposes we want to construct the HTLC Script but then convert it into a P2WSH ScriptPubKey.</p>
<p>Constructing the script uses the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/main/exercises/loop-out/CreateHtlcDescriptor.ts"><code>createHtlcDescriptor</code></a> method which generates a Script that looks like:</p>
<pre><code>OP_SHA256
&lt;32-byte hash&gt;
OP_EQUAL
OP_IF
    OP_DUP
    OP_HASH160
    &lt;20-byte claim pubkeyhash&gt;
OP_ELSE
    28
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    OP_DUP
    OP_HASH160
    &lt;20-byte refund pubkeyhash&gt;
OP_ENDIF
OP_EQUALVERIFY
OP_CHECKSIG
</code></pre>
<p>We are going to use the <code>pubkeyhash</code> construction inside our HTLCs as defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0199.mediawiki">BIP199</a>. This saves us 21-bytes compared to using 33-byte public keys and <code>OP_CHECKSIG</code>. Also if you recall from above where the client and server exchange information, this is why we can use Bitcoin P2WPKH addresses instead of sharing public keys.</p>
<p>Now that we have the HTLC script, we'll perform a sha256 on this script to convert it into the P2WSH ScriptPubKey. We'll serialize it to a hex string for simple comparison when we receive a block.</p>
<pre><code class="language-typescript">const htlcScriptPubKeyHex = Bitcoin.Script.p2wshLock(htlcDescriptor)
  .serializeCmds()
  .toString(&quot;hex&quot;);
</code></pre>
<p>The result will look like:</p>
<pre><code>00&lt;32-byte sha256(htlc_script)&gt;
</code></pre>
<p>Now that we know what to watch for, we can start watching blocks. To do this we use the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/main/exercises/loop-out/BlockMonitor.ts"><code>BlockMonitor</code></a> type which allows us to scan and monitor the blockchain.</p>
<pre><code class="language-typescript">monitor.addConnectedHandler(async (block: Bitcoind.Block) =&gt; {
  for (const tx of block.tx) {
    for (const vout of tx.vout) {
      if (vout.scriptPubKey.hex === htlcScriptPubKeyHex) {
        // Upon finding the HTLC on-chain, we will now generate
        // a claim transaction
        logger.info(&quot;found on-chain HTLC, broadcasting claim transaction&quot;);
        const claimTx = createClaimTx(
          htlcDescriptor,
          preimage,
          htlcClaimPrivKey,
          htlcValue,
          `${tx.txid}:${vout.n}`
        );

        // Broadcast the claim transaction
        logger.debug(&quot;broadcasting claim transaction&quot;, claimTx.toHex());
        await wallet.sendTx(claimTx);
      }
    }
  }
});
</code></pre>
<p>The above code attaches a handler function that is executed for each block. We check each output by looking at the <code>scriptPubKey</code>. If it matches the previously computed <code>scriptPubKeyHex</code> of our HTLC then we have found the HTLC!</p>
<p>When we see the HTLC on-chain, we construct our claim transaction using the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/main/exercises/loop-out/client/CreateClaimTx.ts"><code>createClaimTx</code></a> method. The claim transaction is defined as:</p>
<ul>
<li>version: 2</li>
<li>locktime: 0xffffffff</li>
<li>txin count: 1
<ul>
<li><code>txin[0]</code> outpoint: <code>txid</code> and <code>output_index</code> of the on-chain HTLC</li>
<li><code>txin[0]</code> sequence: 0xffffffff</li>
<li><code>txin[0]</code> scriptSig bytes: 0</li>
<li><code>txin[0]</code> witness: <code>&lt;claim_signature&gt; &lt;claim_pubkey&gt; &lt;preimage&gt; &lt;htlc_script&gt;</code></li>
</ul>
</li>
<li>txout count: 1
<ul>
<li><code>txout[0]</code> value: <code>htlc_amount</code> less <code>fee</code> (fee currently fixed at 1sat/byte = 141)</li>
<li><code>txout[0]</code> scriptPubKey : <code>00&lt;20-byte claim pubkey hash&gt;</code></li>
</ul>
</li>
</ul>
<p>We broadcast our claim transaction and our mission is complete! We have successfully moved funds from our Lightning Network channel to our claim pubkey address.</p>
<p>Next we'll take a look at the service.</p>
<h2 id="building-a-loop-out-service"><a class="header" href="#building-a-loop-out-service">Building a Loop-Out Service</a></h2>
<p>The service piece is a bit more complicated. As discussed, our service needs to do a few things:</p>
<ol>
<li>Receive requests and create a hold invoice</li>
<li>Upon receipt of a hold invoice payment, construct an on-chain HTLC</li>
<li>Watch the HTLC for settlement</li>
<li>Extract the preimage from the on-chain settlement and resolve the incoming hold invoice</li>
</ol>
<p>I like to think of a request in its various states and we can model this as such:</p>
<p><img src="advanced/../images/loop_out_server_states.jpg" alt="Request States" /></p>
<p>For the sake of simplicity, we'll be ignore the timeout paths (dotted lines). As a result our states will traverse through a linear progression of events.</p>
<p>The <a href="https://github.com/bmancini55/building-lightning-advanced/blob/main/exercises/loop-out/service/Service.ts">entrypoint</a> of the service includes some boilerplate to connect to our LND node, connect to bitcoind, and start an HTTP API to listen for requests.</p>
<p>Another thing that happens at the entry point is that our service adds funds to our wallet using the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/9529d8b39f2d4591d09d717d5d410d76255b7c85/exercises/loop-out/Wallet.ts#L36"><code>fundTestWallet</code></a> method. Our wallet implementation runs on regtest which allows us to generate funds and blocks as we need them. The funds in our wallet will be spent to the on-chain HTLC that the service creates after we receive payment of an incoming hold invoice.</p>
<p>Once we have some funds ready to go we can start our <a href="https://github.com/bmancini55/building-lightning-advanced/blob/main/exercises/loop-out/service/Api.ts">API</a> and listen for requests. The API simply translates those requests from JSON and supplies the resulting request object into the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/main/exercises/loop-out/service/RequestManager.ts"><code>RequestManager</code></a> which is responsible for translating events into changes for a request.</p>
<p>Let's now work our way through the service and discuss what happens.</p>
<p>When a request first comes in our we do a few things in the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/3d0a5c67d1b9fe6676c8e3cc5f0051873a40af14/exercises/loop-out/service/RequestManager.ts#L41"><code>addRequest</code></a> method of the <code>RequestManager</code>.</p>
<ol>
<li>Create a new key for the timeout path of our on-chain HTLC</li>
<li>Generate a hold invoice payment request that is for the requested amount + fees we want to charge for looping-out.</li>
<li>Start watching for changes to the invoice.</li>
</ol>
<p>At this point the service can send back the payment request an the refund address we just created.</p>
<p>Our request is now <code>awaiting_incoming_htlc_acceptance</code>, meaning we are waiting for the requestor to pay the invoice before we broadcast the on-chain HTLC.</p>
<p>When the requestor finally pays the invoice our service will be notified that the LN payment has been accepted. This will trigger the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/3d0a5c67d1b9fe6676c8e3cc5f0051873a40af14/exercises/loop-out/service/RequestManager.ts#L81"><code>onHtlcAccepted</code></a> method of the <code>RequestManager</code>. This method will construct and broadcast our HTLC transaction.</p>
<p>To construct the the HTLC transaction we use <a href="https://github.com/bmancini55/building-lightning-advanced/blob/864031f737e66ac73c3f19dddc06245166a316c1/exercises/loop-out/service/RequestManager.ts#L181"><code>createHtlcTx</code></a> method. The transaction is constructed according to the following:</p>
<ul>
<li>version: 2</li>
<li>locktime: 0xffffffff</li>
<li>txin count: 1
<ul>
<li><code>txin[0]</code> outpoint: some available UTXO from our wallet</li>
<li><code>txin[0]</code> sequence: 0xffffffff</li>
<li><code>txin[0]</code> scriptSig bytes: 0</li>
<li><code>txid[0]</code> witness: standard p2wpkh spend</li>
</ul>
</li>
<li>txout count: 2
<ul>
<li><code>txout[0]</code> value: <code>htlc_amount</code> less <code>service_fee</code> (cost to loop out is set at 1000 sats)</li>
<li><code>txout[0]</code> scriptPubKey : <code>00&lt;32-byte sha256(htlc_script)&gt;</code></li>
<li><code>txout[1]</code> value: change amount</li>
<li><code>txout[1]</code> scriptPubKey: p2wpkh change address</li>
</ul>
</li>
</ul>
<p>As we discussed in the previous section our transaction will contain one P2WSH output with the HTLC script. It pays out the amount specified in the loop-out request less the fees we use for service. Recall that the script we use for this is:</p>
<pre><code>OP_SHA256
&lt;32-byte hash&gt;
OP_EQUAL
OP_IF
    OP_DUP
    OP_HASH160
    &lt;20-byte claim pubkeyhash&gt;
OP_ELSE
    28
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    OP_DUP
    OP_HASH160
    &lt;20-byte refund pubkeyhash&gt;
OP_ENDIF
OP_EQUALVERIFY
OP_CHECKSIG
</code></pre>
<p>The input and second change output are generated by our <a href="https://github.com/bmancini55/building-lightning-advanced/blob/3d0a5c67d1b9fe6676c8e3cc5f0051873a40af14/exercises/loop-out/Wallet.ts#L112">wallet software</a>. The wallet is capable of finding a spendable UTXO and manages adding a change address. This method is a simplification, but our loop-out service would also need to aware of whether funds were available to perform the on-chain transaction. We simplify it by always funding the wallet and assuming we have access to the funds.</p>
<p>After the HTLC transaction is constructed we broadcast it.</p>
<p>Our request is now in the <code>awaiting_onchain_htlc_claim</code> state. We are waiting for the requestor to claim the HTLC by spending it using the preimage path. In order to determine if the HTLC has been spent we use the block monitor to watch for spends out of HTLC outpoint. We do this with the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/3d0a5c67d1b9fe6676c8e3cc5f0051873a40af14/exercises/loop-out/service/RequestManager.ts#L129"><code>checkBlockForSettlement</code></a> method of the <code>RequestManager</code>:</p>
<pre><code class="language-typescript">protected async checkBlockForSettlements(block: Bitcoind.Block): Promise&lt;void&gt; {
    for (const tx of block.tx) {
        for (const input of tx.vin) {
            // Ignore coinbase transactions
            if (!input.txid) continue;

            // Construct the outpoint used by the input
            const outpoint = new Bitcoin.OutPoint(input.txid, input.vout);

            // Find the request that corresponds to this HTLC spend
            const request = this.requests.find(
                p =&gt; p.htlcOutpoint.toString() === outpoint.toString(),
            );

            // If we found a request we can now process the invoice
            if (request) {
                await this.processClaimTransaction(input, request);
            }
        }
    }
}
</code></pre>
<p>When we find a transaction that spends the HTLC outpoint, it means that the requestor has spent the output using the preimage path. We need to extract the preimage so we can settle the incoming hold invoice. We do this with the <a href="https://github.com/bmancini55/building-lightning-advanced/blob/3d0a5c67d1b9fe6676c8e3cc5f0051873a40af14/exercises/loop-out/service/RequestManager.ts#L158"><code>processClaimTransaction</code></a> method of the <code>RequestManager</code> which simply extracts the preimage from the witness data that was used to claim the HTLC. If you recall from the previous section when the claim transaction is build the witness data used to spend the HTLC UTXO is <code>[&lt;claim_sig&gt;, &lt;claim_pubkey&gt;, &lt;preimage&gt;, &lt;htlc_script&gt;]</code>.</p>
<pre><code class="language-typescript">protected async processClaimTransaction(input: Bitcoind.Input, request: Request) {
    request.logger.info(&quot;event: block_connected[htlc_spend]&quot;);

    // Extract the preimage from witness data. It will
    // always be the third witness value since the values
    // are [signature, pubkey, preimage]
    const preimage = Buffer.from(input.txinwitness[2], &quot;hex&quot;);

    // Using the obtained preimage, settle the invoice so
    // we can receive our funds
    if (preimage.length) {
        request.logger.info(&quot;action: settle invoice, preimage=&quot;, preimage.toString(&quot;hex&quot;));
        await this.invoiceMonitor.settleInvoice(preimage);
    }
}
</code></pre>
<p>Once the preimage is extracted we finally settle the hold invoice and retrieve our funds!</p>
<h2 id="try-it-out"><a class="header" href="#try-it-out">Try it out!</a></h2>
<p>You can try it out with Alice and Bob. In this example, Bob is running the service and Alice wants to loop out funds from a channel that has the full balance on her side.</p>
<p>Using <a href="https://lightningpolar.com/">Lightning Polar</a>, create a new environment with two LND nodes (one for Alice and one for Bob) and a single bitcoind back end node.</p>
<p><img src="advanced/../images/ch3_loopout_polar.png" alt="Environment" /></p>
<p>Create a channel from Alice to Bob. This will ensure that all the funds are on Alice's side of the channel.</p>
<p>If you haven't already, clone the <a href="https://github.com/bmancini55/building-lightning-advanced">code repository</a> and run <code>npm install</code>.</p>
<p>Copy <code>.env-sample</code> to <code>.env</code> and configure the follow values from the running Polar environment.</p>
<pre><code># LOOP OUT - ALICE
ALICE_LND_RPC_HOST=
ALICE_LND_CERT_PATH=
ALICE_LND_ADMIN_MACAROON_PATH=

# LOOP OUT - BOB
BOB_LND_RPC_HOST=
BOB_LND_CERT_PATH=
BOB_LND_ADMIN_MACAROON_PATH=

# LOOP OUT - BITCOIND
BITCOIND_RPC_URL=
BITCOIND_RPC_USER=
BITCOIND_RPC_PASSWORD=
</code></pre>
<p>You should now be able to start the server with (which will be run by Bob):</p>
<pre><code>npm start exercises/loop-out/service/Service.ts
</code></pre>
<p>In a separate command line instance start the client from Alice's perspective with:</p>
<pre><code>npm start exercices/loop-out/service/Client.ts
</code></pre>
<p>The client should output something like the following:</p>
<pre><code>&gt; npm start exercises/loop-out/client/Client.ts

&gt; building-lightning-advanced@1.0.0 start
&gt; ts-node &quot;exercises/loop-out/client/Client.ts&quot;

2022-09-16T19:33:13.674Z [DBG] Wallet: adding bcrt1qmmj0kjmklc0zyy62cv4ah4mpzftl0mpcacjzl0
2022-09-16T19:33:13.675Z [INF] LoopOutService: generated claim address bcrt1qmmj0kjmklc0zyy62cv4ah4mpzftl0mpcacjzl0
2022-09-16T19:33:13.675Z [INF] LoopOutService: generated preimage 0353725431741829e4d8aa1c4043143a17b054f9d91ef4e442686a0b63e8a0cc
2022-09-16T19:33:13.675Z [INF] LoopOutService: generated hash 9a6de8835775903af1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d
2022-09-16T19:33:14.635Z [DBG] LoopOutService: service request {
  htlcClaimAddress: 'bcrt1qmmj0kjmklc0zyy62cv4ah4mpzftl0mpcacjzl0',
  hash: '9a6de8835775903af1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d',
  loopOutSats: 10000
}
2022-09-16T19:33:14.673Z [DBG] LoopOutService: service response {
  htlcRefundAddress: 'bcrt1qkh0382sjs5yk5fpy0xvuyra3kqjyg2n63c66jw',
  paymentRequest: 'lnbcrt110u1p3jfnm6pp5nfk73q6hwkgr4u24r4p6yje7qmm69jdgchc86szs2fgvtnpjtawsdqqcqzpgsp52kwapautlasnwtxrykvd5c33pgtdpyemp0667jayla7r5qd4nvjq9qyyssqkahaj2jl3qhhws385xfxxytckyw95mvgp0rz4e58x0lfrxm9gy0yy68uzx8gv790596jdxh028g709vptw67f8vusnlvvnc6efkr4jqqhukl50'
}
2022-09-16T19:33:14.673Z [DBG] LoopOutService: constructed HTLC script OP_SHA256 9a6de8835775903af1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d OP_EQUAL OP_IF OP_DUP OP_HASH160 dee4fb4b76fe1e22134ac32bdbd7611257f7ec38 OP_ELSE 28 OP_CHECKSEQUENCEVERIFY OP_DROP OP_DUP OP_HASH160 b5df13aa1285096a24247999c20fb1b024442a7a OP_ENDIF OP_EQUALVERIFY OP_CHECKSIG
2022-09-16T19:33:14.673Z [DBG] LoopOutService: constructed HTLC scriptPubKey 0020d329c680878d6f1ed02c1977b792907960e83741c0a8fa710d9e8e1d1064aec8
2022-09-16T19:33:14.674Z [INF] LoopOutService: paying invoice
(node:47881) [DEP0123] DeprecationWarning: Setting the TLS ServerName to an IP address is not permitted by RFC 6066. This will be ignored in a future version.
(Use `node --trace-deprecation ...` to show where the warning was created)
2022-09-16T19:33:14.709Z [INF] LoopOutService: invoice status is now:IN_FLIGHT
2022-09-16T19:33:14.736Z [INF] LoopOutService: invoice status is now:IN_FLIGHT
2022-09-16T19:33:15.676Z [INF] LoopOutService: found on-chain HTLC, broadcasting claim transaction
2022-09-16T19:33:15.678Z [DBG] LoopOutService: broadcasting claim transaction 02000000000101b3bbc595448889119329cff40003d64c4f0d3ca39d38e676bc0e2885d10adb070000000000ffffffff018326000000000000160014dee4fb4b76fe1e22134ac32bdbd7611257f7ec38044730440220359873e5ea1a7d902ccddb89802adf44c83b1e5fa742858434d4dafe2661e8a302204862536b12bde0f8a1e1b4d7ce97bfeb2c991956a794ae921f67d11445ffcb31012102bda5f9de10b11b30d4161a7b8595937468f1f246a2bacd127575a1709d3414f9200353725431741829e4d8aa1c4043143a17b054f9d91ef4e442686a0b63e8a0cc5aa8209a6de8835775903af1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d876376a914dee4fb4b76fe1e22134ac32bdbd7611257f7ec38670128b27576a914b5df13aa1285096a24247999c20fb1b024442a7a6888acffffffff
2022-09-16T19:33:15.678Z [INF] Wallet: broadcasting txid 5b62d53e255ff507f40342de79458eec4a65065056821e670add4a2119dd5274
2022-09-16T19:33:16.318Z [INF] LoopOutService: invoice status is now:SUCCEEDED
</code></pre>
<p>On Bob's side of the fence we should see the service output something like the following:</p>
<pre><code>npm start exercises/loop-out/service/Service.ts

&gt; building-lightning-advanced@1.0.0 start
&gt; ts-node &quot;exercises/loop-out/service/Service.ts&quot;

2022-09-16T19:33:06.880Z [DBG] Wallet: adding bcrt1qvcu45durgylgw7s55ecupqccnwr3xy6en302wy
2022-09-16T19:33:06.881Z [DBG] Wallet: adding funds to bcrt1qvcu45durgylgw7s55ecupqccnwr3xy6en302wy
2022-09-16T19:33:08.037Z [INF] Wallet: rcvd 1.00000000 - 2e245a3345649392aed6499cd67ba03ac13b1a58fa9f0097c42d1b21eca2554e:0
2022-09-16T19:33:08.041Z [INF] LoopOutService: listening on 1008
2022-09-16T19:33:14.644Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: state=Pending
2022-09-16T19:33:14.644Z [DBG] Wallet: adding bcrt1qkh0382sjs5yk5fpy0xvuyra3kqjyg2n63c66jw
(node:47871) [DEP0123] DeprecationWarning: Setting the TLS ServerName to an IP address is not permitted by RFC 6066. This will be ignored in a future version.
(Use `node --trace-deprecation ...` to show where the warning was created)
2022-09-16T19:33:14.671Z [DBG] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: generated payment_request lnbcrt110u1p3jfnm6pp5nfk73q6hwkgr4u24r4p6yje7qmm69jdgchc86szs2fgvtnpjtawsdqqcqzpgsp52kwapautlasnwtxrykvd5c33pgtdpyemp0667jayla7r5qd4nvjq9qyyssqkahaj2jl3qhhws385xfxxytckyw95mvgp0rz4e58x0lfrxm9gy0yy68uzx8gv790596jdxh028g709vptw67f8vusnlvvnc6efkr4jqqhukl50
2022-09-16T19:33:14.671Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: state=AwaitingIncomingHtlcAccepted
2022-09-16T19:33:14.680Z [DBG] LndInvoiceMonitor: hash=9a6de8835775903af1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d status=OPEN
2022-09-16T19:33:14.952Z [DBG] LndInvoiceMonitor: hash=9a6de8835775903af1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d status=ACCEPTED
2022-09-16T19:33:14.952Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: event: htlc_accepted
2022-09-16T19:33:14.952Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: action: create on-chain htlc
2022-09-16T19:33:14.953Z [DBG] Wallet: adding bcrt1qc4xqt5s59xrpy3tfumqjt3zhhgxzlhfg4gr7nl
2022-09-16T19:33:14.955Z [DBG] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: htlc transaction 020000000001014e55a2ec211b2dc497009ffa581a3bc13aa07bd69c49d6ae92936445335a242e0000000000ffffffff021027000000000000220020d329c680878d6f1ed02c1977b792907960e83741c0a8fa710d9e8e1d1064aec8fcb8f50500000000160014c54c05d2142986124569e6c125c457ba0c2fdd2802473044022001090c492da2e8c218db536c31661ea0694fb397e6168dece6ce1b022db7f94202205120b48d4378b5ea7809da6115cc2d311dd9c8279320cbcdedb431f3f15e7405012102f916619c65ca521de4f3d0ec6084ff3a9c6260b6b2fdc147c84389f107055dc0ffffffff
2022-09-16T19:33:14.955Z [INF] Wallet: broadcasting txid 07db0ad185280ebc76e6389da33c0d4f4cd60300f4cf29931189884495c5bbb3
2022-09-16T19:33:15.036Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: state=AwaitingOutgoingHtlcSettlement
2022-09-16T19:33:15.233Z [INF] Wallet: sent 1.00000000 - 2e245a3345649392aed6499cd67ba03ac13b1a58fa9f0097c42d1b21eca2554e:0
2022-09-16T19:33:15.233Z [INF] Wallet: rcvd 0.99989756 - 07db0ad185280ebc76e6389da33c0d4f4cd60300f4cf29931189884495c5bbb3:1
2022-09-16T19:33:16.270Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: event: block_connected[htlc_spend]
2022-09-16T19:33:16.270Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: action: settle invoice, preimage= 0353725431741829e4d8aa1c4043143a17b054f9d91ef4e442686a0b63e8a0cc
2022-09-16T19:33:16.282Z [DBG] LndInvoiceMonitor: hash=9a6de8835775903af1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d status=SETTLED
2022-09-16T19:33:16.282Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: event: htlc_settled
2022-09-16T19:33:16.282Z [INF] Request f1551d43a24b3e06f7a2c9a8c5f07d40505250c5cc325f5d: state=Complete
</code></pre>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping Up</a></h2>
<p>Hopefully you've enjoyed this overview. We've see a lot of code to perform a loop-out however heed the caution that this is a simplified example.</p>
<p>A few major things are still not implemented for the brevity of this article:</p>
<ol>
<li>The client needs to validate the invoice it receives is correct</li>
<li>The service needs to implement the HTLC timeout path</li>
<li>The service needs to validate the incoming HTLC code</li>
<li>The service needs to persist requests and be able to recover from failures</li>
<li>Our wallet implementation is rudimentary and no where near production ready for a lot of reasons</li>
</ol>
<p>That said, we hope you enjoyed this article and series. This example in particular starts to bridge the gap between using Lightning and protocol development. If you're interested in the latter, I recommend digging into the <a href="https://github.com/lightning/bolts">BOLT specifications</a>. You'll notice there is some commonality with what we needed to implement for this example.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
